{"meta":{"title":"小付同学的博客","subtitle":null,"description":"个人博客","author":"Fufffh","url":"https://fufffh.github.io","root":"/"},"pages":[{"title":"","date":"2024-10-28T15:05:44.455Z","updated":"2024-10-28T15:05:44.455Z","comments":true,"path":"about/index.html","permalink":"https://fufffh.github.io/about/index.html","excerpt":"","text":"一枚弱省弱校弱蒟蒻 博客作者：Fufffh 浙江工业大学大一在读 QQ : 1971166397 GitHub : https://github.com/Fufffh/ GitHub Of My Blog : https://github.com/Fufffh/Fufffh.github.io.git Email : &#49;&#57;&#55;&#49;&#x31;&#54;&#54;&#x33;&#x39;&#x37;&#x40;&#x71;&#x71;&#46;&#99;&#x6f;&#109; Email : &#x32;&#x30;&#x33;&#57;&#x32;&#x31;&#x30;&#53;&#x38;&#56;&#x40;&#113;&#113;&#x2e;&#99;&#x6f;&#x6d; Email : &#102;&#x31;&#57;&#x37;&#x31;&#x31;&#54;&#x36;&#x33;&#57;&#55;&#64;&#x6f;&#117;&#116;&#x6c;&#x6f;&#111;&#107;&#46;&#99;&#x6f;&#x6d; Luogu : FY210628 CodeForces : FY210628 Minecraft : John_dada"},{"title":"所有分类","date":"2024-10-23T08:47:27.033Z","updated":"2024-10-23T08:47:27.033Z","comments":true,"path":"categories/index.html","permalink":"https://fufffh.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2024-10-27T08:14:45.811Z","updated":"2024-10-27T08:14:45.811Z","comments":true,"path":"friends/index.html","permalink":"https://fufffh.github.io/friends/index.html","excerpt":"欢迎膜拜以下大佬","text":"欢迎膜拜以下大佬"},{"title":"所有标签","date":"2024-10-27T08:40:42.977Z","updated":"2024-10-27T08:40:42.977Z","comments":true,"path":"tags/index.html","permalink":"https://fufffh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C++中的常见运算符","slug":"C-中的常见运算符","date":"2024-10-27T14:39:29.000Z","updated":"2024-10-28T15:19:00.222Z","comments":true,"path":"2024/10/27/C-中的常见运算符/","permalink":"https://fufffh.github.io/2024/10/27/C-%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"算数运算符 加减乘除 + - * / 1234int sum = a + b;int sum = a - b;int sum = a * b;int sum = a / b; // int除法默认向下取整 取模运算 % 1int p = a % b; 理解为做除法得到的余数,例如7 &#x2F; 2 &#x3D; 3……1,1 &#x3D; 7 % 2 赋值运算符 直接赋值 = 1int a = 1; 令a的值为1 复合赋值 += -= *= /= 1234x += 3; // 等价于 x = x + 3x -= 2; // 等价于 x = x - 2x *= 4; // 等价于 x = x * 4x /= 2; // 等价于 x = x / 2 比较运算符== != &gt; &lt; &gt;= &lt;= 123456789101112131415等于 (==)：判断两个值是否相等。if (a == b) &#123; /* ... */ &#125;不等于 (!=)：判断两个值是否不相等。if (a != b) &#123; /* ... */ &#125;大于 (&gt;)：判断左侧值是否大于右侧值。if (a &gt; b) &#123; /* ... */ &#125;小于 (&lt;)：判断左侧值是否小于右侧值。if (a &lt; b) &#123; /* ... */ &#125;大于等于 (&gt;=) 和 小于等于 (&lt;=)：if (a &gt;= b) &#123; /* ... */ &#125;if (a &lt;= b) &#123; /* ... */ &#125; 逻辑运算符&amp;&amp; || ! 12345678与 (&amp;&amp;)：当且仅当两个操作数都为真时，结果为真。if (a &gt; 0 &amp;&amp; b &gt; 0) &#123; /* ... */ &#125;或 (||)：只要有一个操作数为真，结果就为真。if (a &gt; 0 || b &gt; 0) &#123; /* ... */ &#125;非 (!)：取反操作符，返回布尔值的相反值。if (!isValid) &#123; /* ... */ &#125; 位运算符 按位与&amp;对两个数在二进制下进行与运算，只有对应位都为1时结果才为1123int a = 13; // 二进制：1101int b = 11; // 二进制：1011int result = a &amp; b; // result 为 9，二进制：1001 按位或|对两个数在二进制下进行或运算，只要对应位与自身有一个为1，结果就为1123int a = 5; // 二进制：0101int b = 3; // 二进制：0011int result = a | b; // result 为 7，二进制：0111 按位异或^对两个数在二进制下进行异或运算，当对应位不同时（一个为1一个为0）结果为1123int a = 5; // 二进制：0101int b = 3; // 二进制：0011int result = a ^ b; // result 为 6，二进制：0110 左移&lt;&lt;将一个数的二进制数向左移动指定的位数，右侧补012int a = 5; //二进制：0101int result = a &lt;&lt; 1; // result 为 10，二进制：1010，相当于 a * 2 右移&gt;&gt;将一个数的二进制数向右移动指定的位数，右侧补012int a = 5; //二进制：0101int result = a &gt;&gt; 1; // result 为 2，二进制：0010，相当于 a / 2 (向下取整) 三目运算符?: 根据条件不同返回不同的值 12int result = (a &gt; b) ? a : b; // 如果 a 大于 b，则 result 为 a，否则为 b?前为一个布尔型变量进行真假判断，为真返回:前面的值，为假返回:后面的值 指针运算符 地址运算符 &amp;获取变量的地址12int x = 10;int* ptr = &amp;x; // ptr 指向 x 的地址 解引用运算符*访问指针所指向的变量的值1234int x = 10;int* ptr = &amp;x; // ptr 指向 xint value = *ptr; // value 为 10，解引用 ptr 获取 x 的值*ptr = 20; // 将 x 的值改为 20 指针的自加或自减++ --1234int arr[] = &#123;1, 2, 3, 4&#125;;int* ptr = arr; // ptr 指向数组的首元素ptr++; // 现在 ptr 指向 arr[1]int second = *ptr; // second 为 2 其他运算符 自增++将变量加1 12x++; // 后缀自增++x; // 前缀自增 这里我们这样理解，一个是执行完之后自增，一个是先自增再执行 1234int a = 5;int b = a++; //b = 5,a = 6;int a = 5;int b = ++a; //b = 6,a = 6; 所以我们定义一个cnt记录数组长度时，经常这样，cnt即为数组长度 12int cnt = 0;a[++cnt] = number; 当然你也可以这样，前后同一索引代表的元素一样，不过这里cnt-1为数组长度 12int cnt = 1;a[cnt++] = number; 自减少-- 12x--; // 后缀自减--x; // 前缀自减","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://fufffh.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"author":"Fufffh"},{"title":"树状数组","slug":"树状数组","date":"2024-10-27T13:57:52.000Z","updated":"2024-10-28T15:19:08.376Z","comments":true,"path":"2024/10/27/树状数组/","permalink":"https://fufffh.github.io/2024/10/27/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","excerpt":"","text":"","categories":[],"tags":[{"name":"数据结构——进阶","slug":"数据结构——进阶","permalink":"https://fufffh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%BF%9B%E9%98%B6/"}],"author":"Fufffh"},{"title":"并查集","slug":"并查集","date":"2024-10-26T12:00:48.000Z","updated":"2024-10-28T15:19:20.151Z","comments":true,"path":"2024/10/26/并查集/","permalink":"https://fufffh.github.io/2024/10/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"什么是并查集？并查集（Union-Find）是一种数据结构，主要用于处理动态连通性问题。它支持高效的合并（Union）和查询（Find）操作，常用于解决图的连通性、集合的合并等问题。通过并查集，我们可以将两个（或多个）元素合并到一个集合中，并查询两个元素是否同属一个集合。我们通过数组来实现这个操作 代码示范指的是第i个元素的祖宗（可以理解为一个集合中的祖宗，代表这个集合）一开始认为所有点都是孤立的一个集合，每个元素的祖宗就是它本身 1234int fa[MAXN];...... for(int i = 1; i &lt;= n; i++) fa[i] = i; 找祖宗的操作，如果一个节点的祖宗不是它本身,那么继续递归，直到一个元素的祖宗为自身（祖宗元素），返回集合的祖宗 12345int find(int x){ if(fa[x] == x) return fa[x]; return find(fa[x]);} 下面是合并操作，如果两个元素a、b不是同一个祖宗，那么将a的祖宗的直系父亲设为b后续find(a)操作递归过程中会变为find(b)的找b祖宗的过程 123456789for(int i = 1 ;i &lt;= m; i++){ int a,b; scanf(\"%d%d\",&amp;a,&amp;b); a = find(a); b = find(b); if(a!=b) fa[a] = b;} 当然你也可以把合并操作写到一个子函数里面 12345678void join(int a,int b){ int f1 = find(a); int f2 = find(b); if(f1!=f2) fa[f1] = f2;}...... join(a,b); 模板题https://www.luogu.com.cn/problem/P1551https://www.luogu.com.cn/problem/P3367这是两道模板题，大家可以前往自己进行代码自测。上述已经给出了合并与寻找的操作，这里只给出一个查询两元素是否同集合的伪代码 12345678910for(int i = 1; i &lt;= p; i++){ int a,b; scanf(\"%d%d\",&amp;a,&amp;b); a = find(a); b = find(b); if(a == b) printf(\"Yes\\n\"); else printf(\"No\\n\");} CF 970 (Div. 3) Problem D题目来源：https://codeforces.com/contest/2008/problem/D或者点击此处前往洛谷自测 题目描述 对于某个排列 ： 如果可以通过赋值 一定次数使 等于 ，则樱子称整数 可以从整数 到达。例如，如果 ，那么，举例来说， 可以从 到达，因为 现在是 ，所以 可以从 到达。 排列中的每个数字都被染成黑色或白色。 樱子将函数 定义为从 可以到达的黑色整数的个数。 樱子对每个 的 都很感兴趣，但计算所有值变得非常困难，因此她请你作为她的好朋友来计算这个值。 长度为 的排列是由 个不同的整数组成的数组，这些整数从 到 按任意顺序排列。例如， 是一个排列，但 不是一个排列（数字 在数组中出现了两次）， 也不是一个排列（ ，但数组中包含 ）。 输入格式 第一行包含一个整数 ( ) — 测试用例数。 每个测试用例的第一行包含一个整数 ( ) — 测试用例中的元素个数。 每个测试用例的第二行包含 个整数 ( ) — 排列元素。 每个测试用例的第三行包含一个长度为 的字符串 ，由 ‘0’ 和 ‘1’ 组成。如果 ，那么数字 被涂成黑色；如果 ，那么数字 被涂成白色。 保证所有测试用例中 的总和不超过 。 输出格式 对于每个测试用例，输出 个整数 。 样例输入 12345678910111213141516511051 2 4 5 31010155 4 1 3 21001163 5 6 1 2 401000061 2 3 4 5 6100110 样例输出 123451 0 1 1 1 1 2 2 2 2 2 4 1 4 4 1 4 0 1 1 0 0 1 思路：本题目实际上就是找到每个元素所在集合的元素的个数我们令表示自然数序号,表示第个数的值每次合并 我们定义一个数组is,表示第i个元素所在集合的黑色块的个数。 前提i为一个集合的祖宗如果s[i] == 0,因为此时所有点还是孤立的（一个点代表一个集合————for(int i = 1; i &lt;= n; i++) fa[i] = i）所以a[i+1]所在集合的黑色块个数为1（它本身） 12345678 int is[200001]; ...... cin&gt;&gt;s; memset(is,0,sizeof(is)); //is默认都为0 for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i];for(int i = 0; i &lt; s.size(); i++) //string索引从0开始 if(s[i]=='0') is[a[i+1]] = 1; //针对string索引从0开始，数组从1开始，数组索引加1 //因为输入的是a[i],所以令is[a[i+1]] = 1 下面进行合并集合的操作，如果两个数、属于两个集合，那么合并后两个集合的黑色块个数相加这里定义f2为合并后的祖宗节点，is[f2]代表合并后集合的黑色块总数 然后按照题意合并 123456789101112void join(int c1,int c2){ int f1 = find(c1),f2 = find(c2); if(f1!=f2) { fa[f1] = f2; is[f2] += is[f1]; }}......for(int i = 1; i &lt;= n; i++) join(i,a[i]); 最后我们只需要输出每个点所在集合的黑色块个数，也就是找到它的祖宗——find(i)，然后is(find(i))即为所求 1for(int i = 1; i &lt;= n; i++) cout&lt;&lt;is[find(i)]&lt;&lt;\" \"; 接下来给出整道题的全部代码 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;int fa[200001];int is[200001];int find(int x){ if(x==fa[x]) return x; return fa[x] = find(fa[x]);}void join(int c1,int c2){ int f1 = find(c1),f2 = find(c2); if(f1!=f2) { fa[f1] = f2; is[f2] += is[f1]; }}int main(){ int t; cin&gt;&gt;t; while(t--) { memset(is,0,sizeof(is)); int n; cin&gt;&gt;n; string s; int a[n+1]; for(int i = 1; i &lt;= n; i++) fa[i] = i; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; cin&gt;&gt;s; for(int i = 0; i &lt; s.size(); i++) if(s[i]=='0') is[a[i+1]] = 1; for(int i = 1; i &lt;= n; i++) join(i,a[i]); for(int i = 1; i &lt;= n; i++) cout&lt;&lt;is[find(i)]&lt;&lt;\" \"; cout&lt;&lt;endl; } return 0;}","categories":[],"tags":[{"name":"数据结构——入门","slug":"数据结构——入门","permalink":"https://fufffh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"}],"author":"Fufffh"},{"title":"堆（heap）","slug":"堆（heap）","date":"2024-10-26T11:57:03.000Z","updated":"2024-10-28T15:18:12.177Z","comments":true,"path":"2024/10/26/堆（heap）/","permalink":"https://fufffh.github.io/2024/10/26/%E5%A0%86%EF%BC%88heap%EF%BC%89/","excerpt":"","text":"前置知识：注意：实现堆需要用到完全二叉树的知识，如果未学习，点击了我也没用，因为我还没写 什么是堆？堆（heap），又叫二叉堆，是一种基于完全二叉树实现的数据结构，它可以实现在堆顶的元素是整个堆里面最大的元素（大根堆），也可以是最小的元素（小根堆），进而获取到整个仪器中的最值的一种数据结构。通过它，我们可以快速获取一组数据中的最值，它的时间复杂度只有O(logn),堆同时也支持删除操作，不过它只能删除堆顶。 图解示范首先我们先看完全二叉树的节点序号如下，可以发现一个父节点和子节点序号的关系：设父节点序号为x,那么左子节点的序号为2x，右子节点的序号为2x+1我们同时也可以知道一个节点x的父节点序号为x/2,（右子节点也是，因为int类型除以2默认向下取整） 首先给出一个堆（这里我们以大根堆为例） 12int w[MAXN];int tot; //当前堆中节点的个数 对于插入操作假如我们插入一个5，我们将其插到数组的最后，作为叶子节点。 如果此时插入的子节点大于其父节点的值，违背了大根堆的性质，那么我们需要堆二叉堆进行修复(modify)操作即向上比较，如果其大于父节点的值，那么便交换两者的位置. 因为5 &gt; 1 所以与其父节点进行位置交换，然后接着进行修复操作，继续向上比较大小 5 &gt; 4,继续与父节点进行位置交换，然后接着向上进行比较，发现小于它的父节点，所以停止修复可见整个修复过程是相对二叉堆来讲自下而上的修复。 接着我们来讲删除堆顶的操作，首先我们无法直接删除堆顶，否则二叉堆会分裂为两棵树，修复麻烦巨大。所以我们寻找一种合适的做法：先把堆顶和堆尾（数组的最后一个数）交换位置 然后我们将交换过去的堆顶在队尾删除。接着我们发现堆顶的元素是一个较小（甚至最小）的数，违背了大根堆的原则，我们又需要对二叉堆进行修复(repair)相对于前者的插入修复，这里的删除修复是一种自上而下的修复。首先比较两个子节点的大小，接着父节点与子节点中较大的一个进行大小的比较，如果小于其中较大的节点，对二者进行交换。选择其中较大的子节点是为了确保如果进行交换，交换上去的子节点是一个更大的数，这样满足大根堆的性质。此处,进行修复（交换0和7），然后接着向下判断 ,进行修复（交换0和6） 每一步也都要对修复的过程进行判断，如果已经是叶子节点（2x &gt; tot） 那么停止修复，这里满足的就是这种情况如果出现父节点的值大于两个子节点的值，也停止修复。 这样，我们就完成了删除堆顶操作的修复操作。 代码示范访问堆顶，很简单，根节点（1）即为最大值 1234int top(){ return w[1];} 修复到的节点序号为x,如果修复过程中x已经是根节点(x == 1)，或者大于其父节点w[x] &lt; w[x/2] 回溯否则，交换x与父节点的值，然后接着向上递归修复。 1234567891011void modify(int x){ if(x == 1 || w[x] &lt; w[x/2]) return; swap(w[x],w[x/2]); modify(x/2);}void push(int x){ w[++tot] = x; //将x加到底部 modify(tot); //自底向上递归修复 } 接下来是删除堆顶操作，详解请看备注讲一下三目运算符 condition ? x : y condition为布尔型判断，为真返回x，为假返回y 123456789101112void repair(int x){ if(x*2 &gt; tot) return; //x已经是叶子节点 int target = x * 2; //target为两个子节点中较大的一个的序号 if(x*2+1 &lt;= tot) target = w[x*2] &gt; w[x*2+1] ? x*2 : x*2+1; //三目运算符，target等于较大一个子节点的序号 //这里是为了防止只有一个子节点的情况出现，所以提前赋值为2x再进行判断。 }void pop(){ swap(w[1],w[tot--]); //交换堆顶与堆尾然后删除堆尾 repair(1) //从根节点开始自上向下修复 } 自此我们实现了堆的所有操作，如果想要判断是否为空和堆的节点个数，通过tot的值便可以实现，这里不再给出具体的代码。 接下来我们引入一个模板题 堆的模板题https://www.luogu.com.cn/problem/P3378这是一道小根堆的模板题，大家可以前往自测，这里不做讲解只给出代码示范 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100000007;int w[MAXN];int cnt = 0;int top(){ return w[1];}void modify(int x){ if(x == 1 || w[x] &gt; w[x / 2]) return; swap(w[x],w[x / 2]); modify(x / 2);}void push(int x){ w[++cnt] = x; modify(cnt);}void repair(int x){ if(x * 2 &gt; cnt) return; int tar = x * 2; if(x*2+1 &lt;= cnt) tar = w[x*2] &lt; w[x*2+1]? x*2:x*2+1; if(w[x] &gt; w[tar]) { swap(w[x],w[tar]); repair(tar); }}void pop(){ if(cnt) { swap(w[1],w[cnt--]); repair(1); } }int main(){ int n; cin&gt;&gt;n; while(n--) { int option; scanf(\"%d\",&amp;option); if(option == 1) { int x; scanf(\"%d\",&amp;x); push(x); } if(option == 2) printf(\"%d\\n\",top()); if(option == 3) pop(); } return 0;} 快速排序（堆排序）题目描述 将读入的 个数从小到大排序后输出。 输入格式 第一行为一个正整数 。 第二行包含 个空格隔开的正整数 ，为你需要进行排序的数。 输出格式 将给定的 个数从小到大输出，数之间空格隔开，行末换行且无空格。 样例输入 1254 2 4 5 1 样例输出 11 2 4 4 5 这是一个通过堆排序实现快排（用小根堆）的模板题，原理就是不断弹出堆顶，来从小到大输出数据。大家可以前往洛谷进行自测 点我跳转对比上一道题，这道题的做法就是将一组数据不断插入堆顶，然后输出一个，pop一个，进行n次操作。下面是伪代码示范 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;......int main(){ int n,x; cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) { cin&gt;&gt;x; push(x); } for(int i = 1; i &lt;= n; i++) { cout&lt;&lt;top()&lt;&lt;\" \"; pop(); } return 0;} 接着我们给出最后一道例题 [NOIP2004 提高组] 合并果子题目描述 在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。 每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。 因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。 例如有 种果子，数目依次为 ， ， 。可以先将 、 堆合并，新堆数目为 ，耗费体力为 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 ，耗费体力为 。所以多多总共耗费体力 。可以证明 为最小的体力耗费值。 输入格式 共两行。第一行是一个整数 ，表示果子的种类数。 第二行包含 个整数，用空格分隔，第 个整数 是第 种果子的数目。 输出格式 一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 。 样例输入 123 1 2 9 样例输出 115 通过题目描述我们不难看出，先合并的石子在后面会参与到后续的合并过程，这就导致它的重量会在后面反复被消耗，即先合并的果子后面其被搬运的次数越多，通过贪心策略我们不难得知，较小的体力消耗的次数越多我们最后体力消耗的总数越少，所以我们实现一个小根堆，每次连续取出两个小根堆堆顶的值，然后再将两个堆顶的和插入到堆中，直到堆为空。接下来给出伪代码 1234567while(tot &gt; 1) //tot为2时搬运最后一次，将最后两堆石子合在一起 { x = top(); pop(); y = top(); pop(); push(x + y); sum+=(x+y);} 优先队列（priority_queue）优先队列（priority_queue）是一种由STL操作的特殊的队列，它可以实现队列的功能，在此之上，实现队首是整个队列中的最大值（或最小值）它的底层逻辑是堆，需要包含&lt;queue&gt;头文件或者万能头，但是它只能访问队首（也就是最值）。接下里我们给出使用方法 12345priority_queue &lt;int&gt; q : 新建一个内部为int类型的优先队列q，默认q为大根堆priority_queue &lt;int,vector &lt;int&gt; ,greater &lt;int&gt; &gt; q : 新建一个小根堆 最后两个&gt; &gt;用空格隔开,否则与\"右移&gt;&gt;\"写法重复 q.top() : 查询优先队列最值（堆顶）q.pop() : 弹出堆顶q.push(k) : 将x插入优先队列 这样我们再回去做合并石子,并用STL操作优先队列来完成这道题目给出代码示范 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n; cin&gt;&gt;n; int ans = 0; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; for(int i = 1; i &lt;= n; i++) { int k; cin&gt;&gt;k; q.push(k); } while(!q.empty()) { int temp = q.top(); q.pop(); temp+=q.top(); q.pop(); ans+=temp; if(!q.empty()) q.push(temp); } cout&lt;&lt;ans; return 0;}","categories":[],"tags":[{"name":"数据结构——入门","slug":"数据结构——入门","permalink":"https://fufffh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"}],"author":"Fufffh"},{"title":"栈（stack）","slug":"栈（stack）","date":"2024-10-26T11:19:00.000Z","updated":"2024-10-28T15:19:04.500Z","comments":true,"path":"2024/10/26/栈（stack）/","permalink":"https://fufffh.github.io/2024/10/26/%E6%A0%88%EF%BC%88stack%EF%BC%89/","excerpt":"","text":"什么是栈？我们先回顾一下我们对于队列的学习。我们对于队列的理解，是一个队伍，在队尾进入，先进先出。那么我们应该通过什么来理解栈呢？你可以想象一堆叠在一起的书构成“书塔”，由下往上叠放。每次放书都放在最上面那层书的上面，如果你想取书，由于书的重力你很难从“书塔”的中间取出来书，所以你只能从这一叠书的最上面取书。所以我们每次取书都是取得最上面得一本。你可以理解为一个单头的队列，只有队首，插入元素和删除元素都是针对队首进行的。这种性质使得栈中先插入的元素会在后插入元素的“下方”,但是出栈是从所谓“上面”出栈，所以这就使得先插入的元素的出栈顺序在后插入的元素之后，所以栈具有先进后出的性质。 栈的代码实现123const int MAXN = 10000007;int stack[MAXN];int p = 0; //栈顶指针 不难理解，依然类似于队列，我们通过数组和指针实现栈。这里的MAXN指的是栈最大支持的大小;接下来是操作代码的实现 12345678910void push(int a){ if(p &gt;= MAXN) cout&lt;&lt;\"Stack overflow（栈溢出）\"; else stack[p++] = x;}void pop(){ if(p == 0) cout&lt;&lt;\"Stack is empty（栈为空）\"; else p--;} 你可以理解下一个插入的元素为stack[p],如果弹出过一次，我们通过更改stack[p-1]来实现所以弹出栈顶用p--来减少指针的值，使得下一次插入的元素通过赋值顶替已经删除的栈顶来实现栈顶的删除。比如3 5 1 7 指针为4,弹出一次操作进行后指针变为3，弹出的元素是stack[3]，下一次插入元素插入到stack[3],通过后续新的元素的插入来实现之前已经删除的栈顶指针索引下的数值的变化（删除）。所以这就是为什么MAXN在队列中表示最大插入次数，因为他的元素没有经过实际意义上数组中的删除，只是滚动过去实现队列的模拟。但在栈中是实际上通过删除来实现的，所以在栈中MAXN指的是栈的大小。 接着给出访问栈顶的代码 123456789int top(){ if(p == 0) { cout&lt;&lt;\"Stack is empty（栈为空）\"; return -1; //指的是栈为空这个概念 } else return stack[p - 1];} 这样我们就实现了栈的基本操作。和队列一样，栈也有对应的STL中的栈,接下来给出通过STL操作的栈的用法。 1234567&lt;stack&gt; : 栈所需要的头文件 stack&lt;int&gt; s : 建立一个栈s,其内部元素类型为ints.push(k) : 将元素k压入栈ss.pop() : 弹出栈顶元素s.top() : 访问栈定元素s.size() : 查询栈s的元素个数s.empty() : 查询s是否为空 写在最后栈的实现相对于队列比较简单，这里不给出具体的例题了，大家可以自行拟定一些数据进行模拟。在栈的基础之上，我们还有一种数据结构——单调栈，它将在后续的进阶数据结构中讲到,敬请期待","categories":[],"tags":[{"name":"数据结构——入门","slug":"数据结构——入门","permalink":"https://fufffh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"}],"author":"Fufffh"},{"title":"队列（queue）","slug":"队列（queue）","date":"2024-10-26T06:59:45.000Z","updated":"2024-10-28T15:19:14.867Z","comments":true,"path":"2024/10/26/队列（queue）/","permalink":"https://fufffh.github.io/2024/10/26/%E9%98%9F%E5%88%97%EF%BC%88queue%EF%BC%89/","excerpt":"","text":"什么是队列？队列（queue）是一种数据结构,它的特点是只允许从队尾入队，从队列头部出队，满足先进先出的性质，即先进入队列的元素先出队列。可以把它理解为排队排在前一个人的后面。比如数字1 5 7 9 2的队列，插入一个元素3，应该插入到队尾，成为3 1 5 7 9 2，再插入一个5，应该排到3的前面，变成5 3 1 5 7 9 2，出队一个头部元素2，则成为3 1 5 7 9，所以满足先进队列的先出队的先进先出性质。此外，队列只允许队首出队，新元素也只能在队尾入队,访问只能访问队首和队尾,无法从中间进行入队出队的操作也无法访问队列中间的元素。 队列（queue）的代码实现123int queue[MAXN];int head = 0;int tail = 0; 数组为队列开辟需要的存储仪器,是队列的最大能入队元素的次数,一般开一个较大的数防止溢出、为指示队首与队尾元素的两个指针。如果有新元素插入，就会插入到这个位置 12345void push(int x){ if(tail &gt;= MAXN) cout&lt;&lt;\"Queue overflow (队列溢出)\"; else queue[tail++] = x; //插入新的元素 } 这是插入操作，我们接着给出出队操作，两个结合着来讲解。 12345void pop() //弹出队首需要判断队列是否为空 { if(head == tail) cout&lt;&lt;\"Queue is empty（队列为空）\"; else head++;} 解释：队列元素插入数组后就一直在数组中，我们通过的是首尾指针的增减来实现队列的还原。比如插入3 5 1，那么queue[0~2]分别指代3 5 1。此时 下次插入会从queue[3]插入元素，queue[head]指代的是队首的3。 函数中会增加队首指针的值，比如进行一次出队操作,增加为1，指代queue[1]，也就是5,但是删除的元素3并不会删除数组，只是两个指针向后滚动来还原整个队列。进行第二次出队,head = 2，指代元素1。如果再进行一次出队，此时已经进行三次出队,head = tail = 3,那么队列为空。这样我们便实现了出队和入队的操作，下面给出访问队首的操作。 123456789int front(){ if(head == tail) { cout&lt;&lt;\"Queue is empty（队列为空）\"; return -1; // 队列为空返回-1，此处也可以返回别的数，因为这并不代表一个对内元素，只代表“空队列”这个概念 } else return queue[head]; //队列不为空，返回队首 } 接下来我们给出一道Luogu例题：https://www.luogu.com.cn/problem/P1996 大家可以在上面自测代码。 约瑟夫问题题目描述 个人围成一圈，从第一个人开始报数,数到 的人出列，再由下一个人重新从 开始报数，数到 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。 输入格式 输入两个整数 。 输出格式 输出一行 个整数，按顺序输出每个出圈人的编号。 样例输入 110 3 样例输出 13 6 9 2 7 1 8 5 10 4 对于这道问题，我们发现会形成一个所谓的约瑟夫环，报数时候如果报的数字不是,那么就可以让把队首放到队尾，通过访问队首元素并将其复制到队尾然后再队首出队实现。报完次后，开始队首出队，出队前输出队首，然后接着循环即可。代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;const int MAXN = 10000007;int queue[MAXN];int head = 0;int tail = 0; int n,m;void push(int x){ if(tail &gt;= MAXN) cout&lt;&lt;\"Queue overflow (队列溢出)\"; else queue[tail++] = x;}void pop(){ if(head == tail) cout&lt;&lt;\"Queue is empty（队列为空）\"; else head++;}int front(){ if(head == tail) { cout&lt;&lt;\"Queue is empty（队列为空）\"; return -1; } else return queue[head]; }int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i = 1; i &lt;= n; i++) push(i); while(head != tail) //如果队列不为空就一直进行循环 { for(int i = 1; i &lt; m; i++) { push(front()); pop(); //上面两步实现了将队首元素换到队尾 } cout&lt;&lt;front()&lt;&lt;\" \"; pop(); //报数到m，队首出队 } return 0;} 我们补充一个访问队尾元素的代码 12345678int back() { if (head == tail) { cout &lt;&lt; \"Queue is empty (队列为空)\"; return -1; } return queue[tail - 1]; // 返回队尾元素} 需要注意的一点，如果这里我们使用的头文件库有queue*或者是包含了该头文件的万能头bits/stdc++.h,数组的命名就不能使用queue。可以使用q或者其他名字来命名数组。那是为什么呢？这里我们引出一个头文件queue中自带的现成的队列，使用STL来进行操作。 STL中的队列（queue）12345678#include&lt;queue&gt; : 队列所需要的头文件queue&lt;int&gt; q : 建立一个队列q，其内部元素类型为intq.push(k) : 将元素k插入队列q中q.pop() : 队列q队首出队q.front() : 访问队列q的队首元素q.back() : 访问队列q的队尾元素q.size() : 查询队列q的元素个数q.empty() : 查询队列是否为空 特别注意： q.empty()为空返回真接着我们使用STL中的队列来重新做一下这道题目 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; queue&lt;int&gt;q; for(int i = 1; i &lt;= n; i++) q.push(i); while(q.size()) //判断队列是否为空，在这里等价为while(!q.empty()) { for(int i = 1; i &lt; m; i++) { q.push(q.front()); q.pop(); } cout&lt;&lt;q.front()&lt;&lt;\" \"; q.pop(); } return 0;} 双端队列（deque）文章的最后我们再给出一个STL中自带的双端队列（deque）,支持队首队尾都能删除和插入元素,用法如下 123456789deque&lt;int&gt; q : 建立双端队列qq.push_back(k) : 在队尾插入元素kq.push_front(k) : 在队首插入元素kq.pop_back() : 移除队尾元素 q.pop_front() : 移除队首元素q.front() : 访问队首元素q.back() : 访问队尾元素q.size() : 查询队列的元素个数 q.empty() : 查询队列是否为空 写在最后自此，我们讲完了队列的实现和使用。队列不仅作用于一些特殊情境的模拟，在一些算法（宽度优先搜索，迪杰斯特拉算法等等）中都有使用。同时它是我们讲解的第一个数据结构，对于后续数据结构的实现和使用了提供了一些思想上的经验。除了上面提到的最常见的队列，以及不常见的双端队列，我们还有一个经常使用的队列，叫做优先队列（priority_queue），不过这是一种基于堆（heap）实现的数据结构，将在后续的文章中进行讲解，如有需要，请点击此处前往学习","categories":[],"tags":[{"name":"数据结构——入门","slug":"数据结构——入门","permalink":"https://fufffh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"}],"author":"Fufffh"},{"title":"线性dp","slug":"线性dp","date":"2024-10-25T15:41:13.000Z","updated":"2024-10-28T15:19:05.726Z","comments":true,"path":"2024/10/25/线性dp/","permalink":"https://fufffh.github.io/2024/10/25/%E7%BA%BF%E6%80%A7dp/","excerpt":"","text":"对于线性动态规划，顾名思义指的就是根据题目内容可以得出线性相关的动态规划，如果书有序列（数组）那么状态就是一维的，如果是网格（棋盘）那么就是二维的。前文引例中的题目便是这种类型的。线性动态规划定义状态通常会考虑某类有序事件前面若干子事件的和 接下来我们给出例题 [HNOI2004] 打鼹鼠题目描述 鼹鼠是一种很喜欢挖洞的动物，但每过一定的时间，它还是喜欢把头探出到地面上来透透气的。根据这个特点阿牛编写了一个打鼹鼠的游戏：在一个 的网格中，在某些时刻鼹鼠会在某一个网格探出头来透透气。你可以控制一个机器人来打鼹鼠，如果 时刻鼹鼠在某个网格中出现，而机器人也处于同一网格的话，那么这个鼹鼠就会被机器人打死。而机器人每一时刻只能够移动一格或停留在原地不动。机器人的移动是指从当前所处的网格移向相邻的网格，即从坐标为 的网格移向 四个网格，机器人不能走出整个 的网格。游戏开始时，你可以自由选定机器人的初始位置。 现在知道在一段时间内，鼹鼠出现的时间和地点，请编写一个程序使机器人在这一段时间内打死尽可能多的鼹鼠。 输入格式 第一行为 （，），其中 表示在这一段时间内出现的鼹鼠的个数，接下来的 行中每行有三个数据 表示在游戏开始后 个时刻，在第 行第 个网格里出现了一只鼹鼠。 按递增的顺序给出。注意同一时刻可能出现多只鼹鼠，但同一时刻同一地点只可能出现一只鼹鼠。 输出格式 仅包含一个正整数，表示被打死鼹鼠的最大数目。 样例输入 1232 2 1 1 1 2 2 2 样例输出 11 我们首先引入一个定义————曼哈顿距离,又叫直角距离，指的是两点间横纵坐标差的绝对值的和，例如、，那么、的曼哈顿距离为 后面我们也会用到曼哈顿距离 未完待续","categories":[],"tags":[{"name":"算法——DP","slug":"算法——DP","permalink":"https://fufffh.github.io/tags/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94DP/"}],"author":"Fufffh"},{"title":"动态规划（DP）的引入","slug":"动态规划（DP）的引入","date":"2024-10-24T11:43:56.000Z","updated":"2024-10-28T15:19:18.930Z","comments":true,"path":"2024/10/24/动态规划（DP）的引入/","permalink":"https://fufffh.github.io/2024/10/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88DP%EF%BC%89%E7%9A%84%E5%BC%95%E5%85%A5/","excerpt":"","text":"动态规划的介绍动态规划(Dynamic Programming)，简称DP，是运筹学的一个分支，用于解决多阶段决策过程中的最优化的一种数学方法，把多阶段问题变换为系列单阶段的问题加以解决的方法。 所以动态规划其实是一种数学方法，是求解某类问题的一种方法，不是一种特定的算法，更没有标准的数学表达式或者明确的定义的一种规则。 动态规划的根本是一种解决问题的思路，思考问题的方式，而不是具体的方法。所以动态规划的难点是思想上的，在于如何学会这种思想。这导致如果我们学习不善，很多时候会构造不出来动态规划所需要的形式，甚至根本想不到这是一道动态规划的问题。 而动态规划的基本思想，就是将一个大问题分解成若干个简单的小问题来求解。其中每一个阶段都需要做出决策，从而使得整个过程达到最优。 动态规划的三个重要要素 状态动态规划的状态可以相对笼统的理解为“问题所在的局面”，例如，“从第i个数字到第j个数字的最大下降子系列”就是状态，是一种关于i,j的局面，然后“最”大下降子序列就是问题所对应的最优答案。某状态表示的答案（的值），方案（集合），在本质上相同，通常会用一个字母（或）表示。状态的答案只依赖状态定义的局面和一些状态以外的常量。在一般情况下，状态变化不会影响状态以外的量，同时状态之后的演变也不受这个状态之前决策的影响。所以在使用动态规划时，应该将所有的可能的变动加入状态的定义中去。同时我们也要定义一个初始状态，即初始化，也称为边界条件 状态转移与状态转移方程因为要求解最终状态的答案，所以状态之间需要存在某些关系，一般把这种计算关系称作转移，关系式称为状态转移方程。寻找状态转移方程也是求解动态规划问题答案的关键所在。状态转移方程一般具有它自己的意义，体现的是从一个状态到另一个状态的变化。对于最优化问题来说，转移方程的目的就是找到最优的前继情况的答案并取出最优答案。前继状态的最优解与当前状态之间最优解的关联性被成为动态规划的最优子结构性质。对于计数问题来说，转移方程的目的就是不遗漏、不重复地统计所有可能的方案数。状态转移存在两种方式，被称为发送型和接收型，前者枚举状态的后继，并计算对后继的贡献;后者枚举状态的前继，当即计算出状态的答案。选取主要取决于前后继状态枚举的难度和转移的复杂程度。 无后效性各阶段的决策的一个前提是“仅需要依赖当前状态”，指的是问题的历史状态不影响未来的发展，可以理解为一个局面可以从哪些局面转移过来的单向依赖关系，如果两个局面可以“相互依赖”，即相互转移到达，那么这个问题，或者说你所定义的当前的这个状态，不具备用动态规划解决的性质。比如从一道题：一个人从左上角到右下角，其间有各种障碍，问最短路径。当你走到某一个点位的时候，你定义的状态应该是向右或者向下，而不是向左或者向上，因为如果这样，那么该点局面就会转移到上方或者左方，是反向的，形成了所谓的“双向依赖”，这种互相达到是动态规划不可以拥有的。我们将这种状态之间不能互相达到的性质以及未来与过去无关的性质统称为动态规划的无后效性。 接下来我们通过例题进行演示最长字段和题目描述给出一个长度为n的序列a,选中期中连续且非空的一段使得这段和最大。 输入格式：第一行是一个整数n,表示序列的长度；第二行有n个整数，第i个整数表示。 输出格式：输出一个整数表示答案。 样例 输入72 -4 3 -1 2 -4 3 输出4 我们定义一个 表示从从1到i之间的最大子段和 首先需要初始化 对于，有两种方式转移过来一种是时，我们可以选择枚举到第i个数的最大子段和为第i个数的值加上一种是时，我们选择枚举到第i个数的自打字段和为 对于这个转移，我们可以进一步思考，如果，那么同理,如果，那么。 则我们可以写出状态转移方程 还需要一个 维护一个ans为最大值 接下来给出代码 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 10000007;int n,f[MAXN],a[MAXN],ans = -1*MAXN;int main(){ cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; for(int i = 1; i &lt;= n; i++) { f[i] = max(f[i - 1] + a[i],a[i]); ans = max(ans,f[i]); //维护一个ans为最大值 } cout&lt;&lt;ans; return 0;} 当然对于此题的状态转移方程，我们也可以写为 这与上式是等价的接下来我们来看下一道例题 长廊灯泡问题题目描述长廊的墙上等距离排列着一列灯泡，每个灯泡发出的亮度不一样，因为灯泡的质量不达标，所以不能出现两个相邻灯泡都打开的情况，否则会因为温度过高导致灯泡毁坏。问灯泡应该怎样开，才可以使长廊的总亮度最大？输出这个最大值。 输入格式：第一行是一个整数n,表示灯泡的数量；第二行有n个整数，第i个整数表示灯泡的亮度。 输出格式：输出一个整数表示答案。 样例 输入52 7 9 3 1 输出12 对于这道题目，可以理解为求不相邻数字和的最大值。 首先定义一个,表示1到i个数字的不相邻数字和的最大值 初始化 表示第1个灯泡和第2个灯泡只能开一个 接着分析的转移对于第i个灯泡，有两种情况 如果第i-1个灯泡未开，那么第i个灯泡可以开，即 如果第i-1个灯泡打开了，那么第i个灯泡则不能打开，则 我们可以得到状态转移方程 即为最终答案代码示例如下 12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 10000007;int n,f[MAXN],a[MAXN];int main(){ cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; f[1] = a[1]; f[2] = max(a[1],a[2]); for(int i = 1; i &lt;= n; i++) f[i] = max(f[i - 2] + a[i],f[i - 1]); cout&lt;&lt;f[n]; return 0;} 接着我们给出最后一道例题 [NOIP2002 普及组] 过河卒题目描述棋盘上 点有一个过河卒，需要走到目标 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。 棋盘用坐标表示， 点 、 点 ，同样马的位置坐标是需要给出的。 现在要求你计算出卒从 点能够到达 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。 输入格式一行四个正整数，分别表示 点坐标和马的坐标。 输出格式一个整数，表示所有的路径条数。 样例 输入6 6 3 3 输出6 我们首先分析这道题目，一个点可以由它的上一个点和左边一个点得到，同时也可以由它的右边和下面的点得到。但是dp的一个根本思想是不能形成相互依赖的结构，如果这样，那么便会形成。因为题目是从左上角到右下角，所以一个点的答案只由它左边和上面的点转移而来。是二点方案数的总和。所以我们的转移方程不难推出 后面给出代码解析 123456789#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,x,y;long long f[50][50]; // 到坐标(i,j)时的方案总数 //十年oi一场空，不开long long见祖宗 bool is[50][50]; // 判断是否可以经过 //数组开大一点 不然跳马可能会越界导致结果出现错误 int move_x[8] = {1,1,2,2,-1,-1,-2,-2};int move_y[8] = {2,-2,1,-1,2,-2,1,-1}; //马的八种移动方式对应的坐标的变化 解释一下 这里需要开long long是因为会出现爆int的情况，这道题也确实卡了int，这在算法题目中需要注意is数组开大，是因为跳马的落脚点可能超出数组的范围，导致数组越界产生报错。 12345678910111213141516cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y; memset(is,true,sizeof(is)); //默认全部点位可经过 memset(f,0,sizeof(f)); //答案默认为0 is[x][y] = false; //马所在的点为控制点之一，不可经过 for(int i = 0; i &lt; 8; i++) is[x + move_x[i]][y + move_y[i]] = false; //八个跳马点标记为不可经过 for(int i = 0; i &lt;= n; i++) { if(!is[i][0]) break; f[i][0] = 1; } for(int j = 0 ; j &lt;= m; j++) { if(!is[0][j]) break; f[0][j] = 1; } //第0行的都是1，如果有一个点是控制点，那么该点之后的点以及该点都为0 首先前四行代码不难理解后面代码的解释：第0行，第0列的所有数的值都应该是1，但是如果期中有一个点是落脚点，那么它无法向后（向下）转移，那么该点之后（包括该点）的所有答案数都应该为0.后面几行代码实现了这样一种落脚点在第0行（列）的特殊情况 接下来给出状态转移的代码 123for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) if(is[i][j]) f[i][j] = f[i - 1][j] + f[i][j - 1]; //状态转移方程 全部代码如下 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,x,y;long long f[50][50];bool is[50][50];int move_x[8] = {1,1,2,2,-1,-1,-2,-2};int move_y[8] = {2,-2,1,-1,2,-2,1,-1}; int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y; memset(is,true,sizeof(is)); memset(f,0,sizeof(f)); is[x][y] = false; for(int i = 0; i &lt; 8; i++) is[x + move_x[i]][y + move_y[i]] = false; for(int i = 0; i &lt;= n; i++) { if(!is[i][0]) break; f[i][0] = 1; } for(int j = 0 ; j &lt;= m; j++) { if(!is[0][j]) break; f[0][j] = 1; } for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) if(is[i][j]) f[i][j] = f[i - 1][j] + f[i][j - 1]; cout&lt;&lt;f[n][m]; return 0;}","categories":[],"tags":[{"name":"算法——DP","slug":"算法——DP","permalink":"https://fufffh.github.io/tags/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94DP/"}],"author":"Fufffh"},{"title":"宽度优先搜索（BFS）","slug":"宽度优先搜索（BFS）","date":"2024-10-20T04:19:04.000Z","updated":"2024-10-28T15:19:12.520Z","comments":true,"path":"2024/10/20/宽度优先搜索（BFS）/","permalink":"https://fufffh.github.io/2024/10/20/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89/","excerpt":"","text":"前置知识注意 该算法的前置知识为队列（queue）,如果没有学习，请点击这里进行学习 BFS的介绍BFS（宽度优先搜索 Breadth-First Search）是一种用于图的遍历或搜索的算法。它从一个节点开始，逐层遍历图中的所有节点。BFS通常用队列来实现，因为它需要按照节点的发现顺序来访问它们。 工作原理BFS的工作原理可以总结为以下几个步骤 循环：只要队列不为空，就执行以下操作： 出队一个节点（我们称之为当前节点）。 访问当前节点的所有未访问的邻居节点（子节点）。 将每个未访问的邻居节点（子节点）标记为已访问，并将其入队。 BFS算法的特点 层级遍历：它按层级顺序访问节点，这意味着它会先访问所有与源节点相邻的节点，然后是那些节点的邻居，以此类推。 最短路径：在无权图中，BFS可以找到从源节点到其他任何节点的最短路径。 时间复杂度：对于有V个顶点和E条边的图，BFS的时间复杂度是O(V+E)。 空间复杂度：在最坏的情况下，BFS可能需要O(V)的空间来存储所有节点的访问状态。 图示演示下面进行进行图示演示： 首先1为根节点 假如我们使用的是DFS，那么DFS序如下 如果我们使用BFS，那么可以理解为按照深度对图进行分层，例如下图，分为1-4共4层，每次遍历先遍历完上一层的所有节点，接着再遍历下一层，首先根节点1入队,遍历完1之后，1的所有子节点入队，1做一次标记并且退队 然后接着对队列中的元素2、3、4、5进行遍历，遍历完2后将2的子节点入队并且对2做标记且让2出队，后续接着遍历完3、4、5，各自子节点入队后各自再做一次标记并退队 接着遍历队列中的元素，直到最后一个元素退队后没有新的元素入队，即队列为空，遍历结束 例题：马的遍历依然是DFS中出现的这道Luogu例题： https://www.luogu.com.cn/problem/P1443 我们接下来用BFS的方法解答一下 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int num[401][401]; //存一下答案，num[i][j]为马到点(i,j)所需要的最小步骤数 struct node&#123; int x,y;&#125;; //定义一个结构体,存储一个点的x,y坐标 queue&lt;node&gt;q; //使用stl自带的队列 也可以自己手写一个 int move_x[8] = &#123;1,1,2,2,-1,-1,-2,-2&#125;;int move_y[8] = &#123;2,-2,1,-1,2,-2,1,-1&#125;; //马的八种移动方式对应的坐标变化 int main()&#123; int n,m,begin_x,begin_y; cin&gt;&gt;n&gt;&gt;m&gt;&gt;begin_x&gt;&gt;begin_y; memset(num,-1,sizeof(num)); //初始化所有答案为-1 num[begin_x][begin_y] = 0; //马到初始点的距离为1 node tmp = &#123;begin_x,begin_y&#125;; //将起点入队 q.push(tmp); ......&#125; 接下来开始BFS，代码如下 12345678910111213141516while(!q.empty()) //队列不为空，就继续进行 &#123; node now = q.front(); //遍历对首并取值 q.pop(); //弹出队首 int now_x = now.x;int now_y = now.y; //储存队首的坐标 for(int i = 0; i &lt; 8; i++) &#123; int next_x = now_x + move_x[i]; int next_y = now_y + move_y[i]; //八个坐标值变化情况 if(next_x &lt; 1 || next_y &lt; 1 || next_x &gt; n || next_y &gt; m || num[next_x][next_y] != -1) continue; //如果x,y坐标不符合图示，或者num[next_x][next_y] != -1,即next点已经被遍历过，舍弃该种情况 num[next_x][next_y] = num[now_x][now_y] + 1; //更新答案，下一个点位为上一个点位的距离加1 node t = &#123;next_x,next_y&#125;; //访问next节点 q.push(t); //将next节点插入队尾 &#125;&#125; 然后我们就完成了对所有情况的遍历，接着对答案进行输出 12345for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++) cout&lt;&lt;num[i][j]&lt;&lt;&quot; &quot;; //场宽 cout&lt;&lt;endl; //换行 &#125; 然后我们就完成了这道题目。全部代码如下 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;int num[401][401];struct node&#123; int x,y;&#125;;queue&lt;node&gt;q;int move_x[8] = &#123;1,1,2,2,-1,-1,-2,-2&#125;;int move_y[8] = &#123;2,-2,1,-1,2,-2,1,-1&#125;;int main()&#123; int n,m,begin_x,begin_y; cin&gt;&gt;n&gt;&gt;m&gt;&gt;begin_x&gt;&gt;begin_y; memset(num,-1,sizeof(num)); num[begin_x][begin_y] = 0; node tmp = &#123;begin_x,begin_y&#125;; q.push(tmp); while(!q.empty()) &#123; node now = q.front(); q.pop(); int now_x = now.x;int now_y = now.y; for(int i = 0; i &lt; 8; i++) &#123; int next_x = now_x + move_x[i]; int next_y = now_y + move_y[i]; if(next_x &lt; 1 || next_y &lt; 1 || next_x &gt; n || next_y &gt; m || num[next_x][next_y] != -1) continue; num[next_x][next_y] = num[now_x][now_y] + 1; node t = &#123;next_x,next_y&#125;; q.push(t); &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) cout&lt;&lt;num[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"算法——基础","slug":"算法——基础","permalink":"https://fufffh.github.io/tags/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80/"}],"author":"Fufffh"},{"title":"深度优先搜索（DFS）","slug":"深度优先搜索（DFS）","date":"2024-10-19T15:47:34.000Z","updated":"2024-10-28T15:19:09.441Z","comments":true,"path":"2024/10/19/深度优先搜索（DFS）/","permalink":"https://fufffh.github.io/2024/10/19/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89/","excerpt":"","text":"DFS的介绍DFS（深度优先搜索，Depth-First Search）是一种用于遍历或搜索树或图的算法。它从一个节点开始，尽可能深地搜索树的分支，直到到达叶子节点（没有子节点的节点），然后回溯到上一个节点，继续搜索其他分支。这个过程会一直进行，直到所有可能的分支都被探索完毕。 工作原理DFS的工作原理可以总结为以下几个步骤 选择一个起始节点：从树或图的某个节点开始。 探索尽可能深的分支：从当前节点开始，选择一个未被访问过的邻接节点，然后递归地在该节点上执行DFS。 回溯：当当前节点的所有邻接节点都被访问过，或者到达了叶子节点时，回溯到上一个节点。 重复：重复步骤2和3，直到所有节点都被访问过。 DFS的特点 栈的使用：在实现DFS时，通常使用栈数据结构来存储节点。在递归实现中，调用栈隐式地充当了栈的角色。 时间复杂度：对于有V个顶点和E条边的图，DFS的时间复杂度通常是O(V + E)。 空间复杂度：在最坏的情况下，DFS的空间复杂度也是O(V)，因为可能需要存储整个路径上的节点。 路径搜索：DFS非常适合于寻找从起点到终点的路径，尤其是在图不是非常大的情况下。 连通性问题：DFS可以用来检测图的连通性，例如，检查一个图是否是强连通的。 图示示例下面是一个简单的图示：节点1为根节点，也叫起始节点那么节点1向下遍历，直到遍历到第一个没有子节点的节点4因为4已经没有子节点，已经是叶子节点，所以无法再向下遍历，所以回溯到上一个它的父节点3，并对节点4作标记，节点3接着向下遍历未被标记的子节点5因为5同样是叶子节点，遍历有到达了最深层，所以继续回溯到父节点3，同时标记5，我们发现3也没有未被标记的子节点了，无法再向下遍历，那么3接着向上回溯到父节点2，同时对3作标记，继续遍历2的未被标记的子节点6接下来过程：2→6→7，节点7向上回溯到6并标记,节点6向下遍历子节点:6→8,然后连续向上回溯 8→6→2→1 直到回溯到根节点1,发现有可以向下遍历的子节点接着按照上述模式进行剩余的遍历，完成整张图的遍历，图的序号即为遍历的顺序 例题：马的遍历这是Luogu上一道搜索的例题 https://www.luogu.com.cn/problem/P1443接着给出示例代码 123456789#include&lt;bits/stdc++.h&gt; //万能头文件 using namespace std; //引用stl库 const int MAXN = 1000009; //定义一个大数 bool is[401][401]; //对一个点(i,j)标记是否已经遍历过 int num[401][401]; //存储起始点(x,y)到每个点(i,j)的距离 int n,m,begin_x,begin_y;int move_x[8] = &#123;1,1,2,2,-1,-1,-2,-2&#125;;int move_y[8] = &#123;2,-2,1,-1,2,-2,1,-1&#125;; //马的八种移动方式对应的(x,y)坐标的变化 初始工作 123456789int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;begin_x&gt;&gt;begin_y; memset(is,true,sizeof(is)); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) num[i][j] = MAXN; dfs(begin_x,begin_y,0); print(); return 0;&#125; main函数的内容如上，初始化标记数组is,为全部未访问过，num[i][j]初始化为一个极大的数dfs(int x,int y,int k)为一个递归函数 x,y:当前点位的横坐标; k:走到目前点位的步数dfs(begin_x,begin_y,0) 即从初始点位开始dfs，步数为0（马到起始点的步数为0） 123456789101112131415161718void dfs(int x,int y,int k)&#123; if(x &lt;= 0||y &lt;= 0||num[x][y] &lt; k||x &gt; n || y &gt; m) return; //如果遍历到的坐标点不在方格图内 即超过了图的横纵坐标或者小于等于0（方格图横纵坐标范围为1~n,1~m） 回溯 //num[x][y] &lt; k ： 如果该点位的答案已经小于现有步数，那么k已经超过了答案，没有必要进行 回溯 num[x][y] = k; //更新num[x][y] for(int i = 0 ;i &lt; 8; i++) //枚举八个走马后的可能坐标值 &#123; int tx = move_x[i] + x; int ty = move_y[i] + y; //(tx,ty) : 走马后的坐标 is[x][y] = false; dfs(tx,ty,k + 1); //向后遍历，步数加1，打标记，防止父子节点反复遍历死循环 is[x][y] = true; //恢复标记，可以再次访问 &#125;&#125; dfs内容如上 接着我们需要对题目所要求的输出进行修改，有格式要求 123456789101112void print()&#123; for(int i = 1 ; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; if(num[i][j] == MAXN) cout&lt;&lt;&quot;-1 &quot;; else cout&lt;&lt;num[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;&#125; 当然你也可以采取下面修改场宽的方式进行所要求格式的输出 1printf(&quot;%-5d&quot;,num[i][j]); 全部代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1000009;bool is[401][401];int num[401][401];int n,m,begin_x,begin_y;int move_x[8] = &#123;1,1,2,2,-1,-1,-2,-2&#125;;int move_y[8] = &#123;2,-2,1,-1,2,-2,1,-1&#125;; void dfs(int x,int y,int k)&#123; if(x &lt;= 0||y &lt;= 0||num[x][y] &lt; k||x &gt; n || y &gt; m) return; num[x][y] = k; for(int i = 0 ;i &lt; 8; i++) &#123; int tx = move_x[i] + x; int ty = move_y[i] + y; is[x][y] = false; dfs(tx,ty,k + 1); is[x][y] = true; &#125;&#125;void print()&#123; for(int i = 1 ; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; if(num[i][j] == MAXN) cout&lt;&lt;&quot;-1 &quot;; else cout&lt;&lt;num[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;begin_x&gt;&gt;begin_y; memset(is,true,sizeof(is)); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) num[i][j] = MAXN; dfs(begin_x,begin_y,0); print(); return 0;&#125; 在代码中，DFS被用来计算从起点开始，到达每个位置所需的最少移动次数。虽然最终结果可能是正确的，但由于DFS的递归性质，它可能会导致大量的函数调用开销，并且可能会在没有找到更优解的情况下继续深入搜索，从而导致效率较低。 接下来 将引入在这个场景下更为合适的另一种搜索方法，宽（广）度优先搜索（BFS）","categories":[],"tags":[{"name":"算法——基础","slug":"算法——基础","permalink":"https://fufffh.github.io/tags/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80/"}],"author":"Fufffh"}],"categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://fufffh.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数据结构——进阶","slug":"数据结构——进阶","permalink":"https://fufffh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%BF%9B%E9%98%B6/"},{"name":"数据结构——入门","slug":"数据结构——入门","permalink":"https://fufffh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"},{"name":"算法——DP","slug":"算法——DP","permalink":"https://fufffh.github.io/tags/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94DP/"},{"name":"算法——基础","slug":"算法——基础","permalink":"https://fufffh.github.io/tags/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80/"}]}