{"meta":{"title":"小付同学的博客","subtitle":null,"description":"个人博客","author":"Fufffh","url":"https://fufffh.github.io","root":"/"},"pages":[{"title":"","date":"2024-10-28T15:05:44.455Z","updated":"2024-10-28T15:05:44.455Z","comments":true,"path":"about/index.html","permalink":"https://fufffh.github.io/about/index.html","excerpt":"","text":"一枚弱省弱校弱蒟蒻 博客作者：Fufffh 浙江工业大学大一在读 QQ : 1971166397 GitHub : https://github.com/Fufffh/ GitHub Of My Blog : https://github.com/Fufffh/Fufffh.github.io.git Email : &#49;&#57;&#55;&#49;&#x31;&#54;&#54;&#x33;&#x39;&#x37;&#x40;&#x71;&#x71;&#46;&#99;&#x6f;&#109; Email : &#x32;&#x30;&#x33;&#57;&#x32;&#x31;&#x30;&#53;&#x38;&#56;&#x40;&#113;&#113;&#x2e;&#99;&#x6f;&#x6d; Email : &#102;&#x31;&#57;&#x37;&#x31;&#x31;&#54;&#x36;&#x33;&#57;&#55;&#64;&#x6f;&#117;&#116;&#x6c;&#x6f;&#111;&#107;&#46;&#99;&#x6f;&#x6d; Luogu : FY210628 CodeForces : FY210628 Minecraft : John_dada"},{"title":"所有分类","date":"2024-10-23T08:47:27.033Z","updated":"2024-10-23T08:47:27.033Z","comments":true,"path":"categories/index.html","permalink":"https://fufffh.github.io/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2024-10-27T08:14:45.811Z","updated":"2024-10-27T08:14:45.811Z","comments":true,"path":"friends/index.html","permalink":"https://fufffh.github.io/friends/index.html","excerpt":"欢迎膜拜以下大佬","text":"欢迎膜拜以下大佬"},{"title":"所有标签","date":"2024-10-27T08:40:42.977Z","updated":"2024-10-27T08:40:42.977Z","comments":true,"path":"tags/index.html","permalink":"https://fufffh.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"基础数论入门","slug":"基础数论入门","date":"2025-02-18T13:00:53.000Z","updated":"2025-02-19T09:13:50.681Z","comments":true,"path":"2025/02/18/基础数论入门/","permalink":"https://fufffh.github.io/2025/02/18/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA%E5%85%A5%E9%97%A8/","excerpt":"","text":"目录本文目录 素数与筛法 GCD与LCM 快速幂 素数与筛法素数的定义素数定义素数（）是一个大于1的自然数，如果它仅有两个正整数因子：1和它自身。换句话说，素数是只能被1和它自己整除的数。形式上，可以表示为： 一个自然数，若且对于所有的，如果能整除(即),那么或。 素数的筛法1.试除筛对于一个大于1的数,我们枚举到之间的所有整数，如果使得,那么为合数（非素数）,否则为素数。复杂度 1234567bool isPrime(int n) { if(n &lt;= 1) return false; for(int i = 2; i * i &lt;= n; i++) if(n % i == 0) return false; return true;}...... 2.埃氏筛标记素数在范围内的所有倍数为非素数，因为对于一个合数的倍数，肯定也是一个比它小的素数的倍数。因为合数肯定有素数因子，即合数至少是一个素数的倍数。所以合数的倍数也是素数的倍数，在枚举过程中，我们遇到一个合数选择跳过，遇到素数，那么标记该素数的所有倍数为非素数。 复杂度 123456789bool is_prime[MAXN];void get_prime(int n) { memset(is_prime, true, sizeof(is_prime)); is_prime[0] = is_prime[1] = false; for(int i = 2; i*i &lt;= n; i++) if(is_prime[i]) for(int j = i*i; j &lt;= n; j += i) is_prime[j] = false;} 3.欧拉筛我们发现埃氏筛中，有的数会被重复枚举到。即一个数可以是多个素数的倍数。比如210,它的质因子同时包含了2、3、5、7，所以会在枚举该四个素数的过程中重复枚举到。欧拉线性筛的关键就在于，使得每个合数只被它的最小质因子筛除，从而保证每个数只会被标记一次。核心思想： 对于每个数,枚举所有小于等于的最小质因数,标记为合数。 当能被整除时，说明是的最小质因子,此时停止标记。 123456789101112131415vector&lt;int&gt; primes; // 存储质数bool is_composite[MAXN]; // 标记是否为合数void get_prime(int n) { for(int i = 2; i &lt;= n; i++) { if(!is_composite[i]) { primes.push_back(i); // i 是质数 } for(int p : primes) { if (i * p &gt; n) break; // 超过范围，退出 is_composite[i * p] = true; // 标记 i*p 为合数 if (i % p == 0) break; // 保证只被最小质因子筛 } }} 实际上内层循环的次数为：。用数学公式表示为：而每个数字只会被其最小质因子标记，实际标记次数远小于,而是接近线性次数。 GCD与LCM部分公式符号说明 整除符号 如果整数被整数整除,即使得,则记作 取余符号 如果使得,记作,为对取余后的余数 gcd(求最大公因数) 规定对于为、的最大公因数 lcm(求最小公倍数) 辗转相除法求gcd(最大公因数)辗转相除法的证明设,则有且 令,其中 可以得到r = a - bq$ 由可以得到,又 则 因此是的公约数,或表示为 且 设,则有: 由可以得到 因此,是、的公约数,则 综上可得：且 则,又 则 不断辗转相除 直到即时, 这也是最后一层相除 gcd代码1234int gcd(int a, int b) { return b == 0 ? a : gcd(b, a % b);} lcm(最小公倍数)根据算数基本定理,任何大于1的整数都可以唯一的分解成为一组质数的乘积,而且这种分解是唯一的。 分别对进行质因数分解,得到: 则有 所以可以得到 互质如果两个数只有1这一个公因数，那么这两个数互质，即,则互质 快速幂快速幂的原理如果我们要求解,可以有以下考虑： 即为偶数,向下递归求解,然后将得到的结果平方,即 即是奇数,向下递归求解,然后将结果平方后乘以b,即 每次求解的大小会减半，直到递归到,所以时间复杂度为 快速幂的实现1234567long long qpow(int y,int x){ if(x == 0) return 1; long long s = qpow(y,x / 2); if(x % 2 == 0) return s * s % mod; else return s * s % mod * y % mod;} 当然调用递归函数会导致常数较大，你可以选择非递归的写法,下面提供一下： 123456789101112long long qpow(long long y,long long x){ if(x == 0) return 1; long long s = 1; while(x) { if(x&amp;1) s = s * y % mod; // 为奇数 y = y * y % mod; x &gt;&gt;= 1; } return s;} 当然你也可以用一行代码来实现 1int qpow(int a, int b) {int res = 1; for(; b; b &gt;&gt;= 1, a = a * a % MOD) if (b &amp; 1) res = res * a % MOD; return res;}","categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"https://fufffh.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"Python基础教程","slug":"Python基础教程","date":"2024-11-07T07:45:45.000Z","updated":"2024-11-25T07:07:47.011Z","comments":true,"path":"2024/11/07/Python基础教程/","permalink":"https://fufffh.github.io/2024/11/07/Python%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/","excerpt":"","text":"前排如果显示有问题,请关闭黑暗模式电脑端滚轴上滑会显示顶端栏,有一个黑暗模式手机端点击右上角，找到黑暗模式 特别鸣谢： 童博扬、王昌翔、张紫涵、石非易 本文内容可能存在错误，欢迎指正习题没有标准答案,提供的题解仅供参考 基本操作数据的输入input()Python程序的输入通过函数input()实现，特别注意，利用input()函数输入的任何数据都是字符串类型所以需要整数数字需要用int()函数转换为整数 如下 1x = int(input(\"请输入x:\")) 其中input()中引号中的内容为显示的内容，不影响程序的运行 变量数据类型int : 整数型str ：字符串类型tuple : 元组类型float : 浮点数类型(可以理解为有小数)list : 列表类型dict : 字典类型range : 数字序列类型Bool : 布尔型 (只含有True和False两个值)*NoneType : 空值类型(None)*set : 无序的不重复集合 变量的赋值操作直接赋值赋值通过符号实现 123&gt;&gt;&gt; x = 5&gt;&gt;&gt; x5 通过,我们将一个值5赋值给了变量 默认是整数int类型它的默认值和你后面的数据有关 比如 123&gt;&gt;&gt; x = \"5\"&gt;&gt;&gt; y = \"abc\"&gt;&gt;&gt; z = True x = “5” 加了引号，则这个x的值5实际上是一个字符串类型，同理下面的y = abc得到的也是一个字符串类型就是一个布尔型 增量赋值对于 变量 += 值,相当于 变量 = 变量 + 值 如下 1234&gt;&gt;&gt; x = 5&gt;&gt;&gt; x += 2 (等价于x = x + 2)&gt;&gt;&gt; x7 链式赋值多个等号赋值 即将x,y,z值都赋值为n 123&gt;&gt;&gt; x = y = z = 5&gt;&gt;&gt; print(x,y,z)5 5 5 位置赋值等号两边的变量分别用逗号隔开,然后根据对应位置进行赋值比如 a,b,c = x,y,z,结果a = x,b = y,c = z; 12# 交换a,b的值a,b = b,a 二、八、十六进制关于进制学习 0b(0B) 二进制12&gt;&gt;&gt; 0b1015 0o(0O) 八进制12&gt;&gt;&gt; 0o10165 0x(0X) 十六进制12&gt;&gt;&gt; 0x101257 字符串ASCII码*介绍通过整数int型对应的字符串,是一种字符编码标准，用于表示文本中常见的字符。它通过给每个字符分配一个整数值，使得计算机能够存储和传输文本信息。ord()：将一个字符转换为对应的 ASCII（或 Unicode）码点。chr()：将一个整数（ASCII 或 Unicode 码点）转换为对应的字符。 1234567891011121314151617181920212223242526272829303132333435363738# 字符 'A' 的 ASCII 码print(ord('A')) # 输出 65# 字符 'a' 的 ASCII 码print(ord('a')) # 输出 97# 空格字符的 ASCII 码print(ord(' ')) # 输出 32# 数字字符 '0' 的 ASCII 码print(ord('0')) # 输出 48# 标点符号字符 '!' 的 ASCII 码print(ord('!')) # 输出 33# 字符 'Z' 的 ASCII 码print(ord('Z')) # 输出 90# 字符 'z' 的 ASCII 码print(ord('z')) # 输出 122###################################### ASCII 码 65 对应的字符print(chr(65)) # 输出 'A'# ASCII 码 97 对应的字符print(chr(97)) # 输出 'a'# ASCII 码 32 对应的字符print(chr(32)) # 输出 ' ' (空格)# ASCII 码 48 对应的字符print(chr(48)) # 输出 '0'# ASCII 码 33 对应的字符print(chr(33)) # 输出 '!' 常见元素的ASCII码 int()整数型与ASCII码的关系为 比如 48的ASCII值对应字符’1’,49对应’2’,……,57对应’9’ A的ASCII码为65,a的ASCII码为97A - Z,a - z的ASCII码可以根据ABCDE……XYZ的顺序推出 B就是66，b就是98 注意：以上不管是ABC，abc,还是0 1 2,ASCII码对应的都是字符型(str),数字也是字符型 索引与切片索引索引就是字符串按顺序从左到右的编号。特别地，如果字符串长度为n,字符串第一个元素地编号为0，最后一个为n-1 从0开始反向索引则第一个为-n,最后一个为-1 则为从-1开始 12345&gt;&gt;&gt; s = \"ABC\"&gt;&gt;&gt; s[0]A&gt;&gt;&gt; s[1]B 正反索引转换为了方便，我们把反索引转换为正索引，下面给出公式：反索引为-i,正索引为n - i正索引为i,反索引为n - i - 1比如反索引为-5，字符串长度为9，正索引为4 切片定义一个字符串s = “abcdefg”切片: s[begin:end:step]begin : 起始索引end : 终止索引(不包括该索引下的字符,可以理解为一个左闭右开区间[begin,end))step : 步长，默认1，可省略起始终止索引如果省略默认为最左边的索引(0)，但是二者中间的 : 不可省略如果起始终止索引都不填，默认为整个字符串看示例： 1234567891011121314&gt;&gt;&gt; s[2:5] #从第三个字符开始，到第5个字符,步长默认为1cde&gt;&gt;&gt; s[2:5:2] #步长改为2ce&gt;&gt;&gt; s[ :5] #默认起始索引为0abced&gt;&gt;&gt; s[2:-3] #-3的正索引为7 - 3 = 4,即为s[2:4]cd&gt;&gt;&gt; s[5: :-2] #默认终止索引为0，步长为负，往左切，从s[5]= f开始fdb 字符串运算符123456789101112131415161718192021222324252627x = \"abc\"y = \"ABC\"# [] 通过索引获取字符&gt;&gt;&gt; x[2]c# [: :] 切片略# + 连接两个字符串&gt;&gt;&gt; x + yabcABC&gt;&gt;&gt; y + x&gt;&gt;&gt; ABCabc# * 重复拼接,理解为做乘法&gt;&gt;&gt; x * 2abcabc# in,not in 判断子字符串是否存在，返回布尔值True or False&gt;&gt;&gt; 'bc' in xTrue&gt;&gt;&gt; 'bd' not in xTrue注意 空格也算一个字符&gt;&gt;&gt; 'b c' in xFalse 字符串中的函数详见P31-P36 课本很详细在文末通过例题进行讲解，这里不赘述 运算符算术运算符12345678910a = 10b = 3print(\"加法:\", a + b) # 输出 13print(\"减法:\", a - b) # 输出 7print(\"乘法:\", a * b) # 输出 30print(\"除法:\", a / b) # 输出 3.3333333333333335print(\"整除:\", a // b) # 输出 3print(\"取余:\", a % b) # 输出 1print(\"幂运算:\", a ** b) # 输出 1000print(\"负号:\", -a) # 输出 -10 其中//整除默认向下取整 运算符优先级顺序（总结）指数运算：** （最高优先级）正负号：+ - （用于表达式的单目运算符）乘法/除法等：* / // %加法/减法：+ -关系运算符：== != &gt; &lt; &gt;= &lt;= （最低优先级）比如x = 5 + 2 * 3 ** 2 == 10 / 2 3 ** 2 = 92 * 9 = 185 + 18 = 2310 / 2 = 5.023 == 5.0，结果为 False 关系运算符123456789101112131415161718192021222324252627a = 10b = 5c = 10# 等于运算符print(a == b) # Falseprint(a == c) # True# 不等于运算符print(a != b) # Trueprint(a != c) # False# 大于运算符print(a &gt; b) # Trueprint(a &gt; c) # False# 小于运算符print(a &lt; b) # Falseprint(a &lt; c) # False# 大于等于运算符print(a &gt;= b) # Trueprint(a &gt;= c) # True# 小于等于运算符print(a &lt;= b) # Falseprint(a &lt;= c) # True 感叹号在这不是阶乘，不是阶乘，等于关系是双等号！双等号！is,not is判断是不是一个内存地址,相当于id(x) ==或!= id(y)的用处只需要记住整数型如果两个数的值相等且该值处于-5~256的闭区间，内存地址一样字符串型号如果只有数字和字母(没有空格)且相同，内存地址一样 逻辑运算符not and or,优先级 not &gt; and &gt; ornot就是对表达式的布尔值取反and就是连接两个表达式，都为真为真，有一个为假则为假or就是两个表达式有一个为真就为真 常见保留关键字False await else import passNone break except in raiseTrue class finally is returnand continue for lambda tryas def from nonlocal whileassert del global not withasync elif if or yield 格式化介绍格式化输出主要使用到f-string和format()两种f-string 更加简洁和高效，推荐在 Python 3.6 及以后的版本中使用，尤其是当你需要直接嵌入变量或表达式时。format 在需要更复杂的格式化控制时更有用，特别是当你需要在同一个字符串中使用多次相同的变量或进行特殊格式化时。课本上给的大多数是format(),考试中的考察大多数也是format()用法,这里我们对两种方法进行讲解后面习题用的是f-string注意 对于一些你想到的但是没有出现的可能，一定要试着自己敲一敲代码看一看结果,切记实践是检验真理的唯一标准 f-string它以字面值字符串的形式在前面加上 f 或 F，并在字符串中使用花括号 {} 来嵌入表达式或变量。意思就是{}中的元素 输出时候会显示它的量,比如x = 1,{x}就是输出1而不是x,但是花括号外就是x如下： 12345678910111213x = 5y = 1print(f\"x\")&lt;&lt;&lt; xprint(f\"{x}\")&lt;&lt;&lt; 5print(f\"x + y = x + y\")&lt;&lt;&lt; x + y = x + yprint(f\"x + y = {x + y}\")&lt;&lt;&lt; x + y = 6 你也可以把它当成一个变量来进行输出 如下 123456x = 5y = 1sum = x + y result = f\"The sum of x + y = {sum}\"print(result)&lt;&lt;&lt; The sum of x + y = 6 format()这里我们详讲一下format()，这是考点之一使用大括号 {} 作为占位符，在 format() 方法中传入相应的值。示例 基本用法12345name = \"Alice\"age = 30greeting = \"Hello, my name is {} and I am {} years old.\".format(name, age) # {}个数和后面format()中元素个数对应一致即可print(greeting)&lt;&lt;&lt; Hello, my name is Alice and I am 30 years old. 位置参数你可以通过在 format() 中指定位置来插入多个变量。位置是从 0 开始的，类似于列表索引。 123greeting = \"Hello, {0}! Today is {1}.\".format(\"Alice\", \"Monday\")print(greeting)&lt;&lt;&lt; Hello, Alice! Today is Monday. 上面括号中的从左到右的索引顺序就是{}的索引 123greeting = \"Hello, {1}! Today is {0}.\".format(\"Monday\", \"Alice\")print(greeting)&lt;&lt;&lt; Hello, Alice! Today is Monday. 关键字参数你也可以使用关键字参数传递值，并在花括号中通过名字来引用它们。如下 123greeting = \"Hello, {name}! Today is {day}.\".format(name=\"Alice\", day=\"Monday\")print(greeting)&lt;&lt;&lt; Hello, Alice! Today is Monday. 重复使用变量示例如下 1234greeting = \"Hello, {0}! Your {0}'s status is confirmed.\".format(\"Alice\") 或者greeting = \"Hello, {name}! Your {name}'s status is confirmed.\".format(name=\"Alice\")print(greeting)&lt;&lt;&lt; Hello, Alice! Your Alice's status is confirmed. 混合用法关键字参数和索引地一起使用 如下 123greeting = \"Hello, {0}! Today is {day}.\".format(\"Alice\", day=\"Monday\")print(greeting)&lt;&lt;&lt; Hello, Alice! Today is Monday. 注意 你可以将位置参数和关键字参数混合在同一个 format() 中，但位置参数必须放在关键字参数之前。比如如下情况就会报错 1234greeting = \"Hello, {0}! Today is {1}.\".format(\"Alice\", day=\"Monday\")greeting = \"Hello, {0}! Today is {1}.\".format(\"Alice\", day=\"Monday\",\"test\")greeting = \"Hello, {0}! Today is {day}.\".format(\"Alice\", day=\"Monday\")greeting = \"Hello, {0}! Today is {day}.\".format(day=\"Monday\",\"Alice\") 即关键字在位置参数变量的后面，而且不算到位置参数里面，即索引的个数只与位置参数有关，与关键字参数的个数无关 数字格式化format 可以用来格式化数字，指定小数位数、宽度、对齐方式等。示例1：小数位数的保留 {:.nf} 保留n位小数 1234pi = 3.14159formatted = \"The value of pi is {:.2f}\".format(pi)print(formatted)&lt;&lt;&lt; 3.14 其中:前面填它的位置参数 12345678pi = 3.14159tx = 2.22222print(\"The value of pi is {0:.2f}\".format(pi,tx))print(\"The value of pi is {1:.2f}\".format(pi,tx))print(\"The value of pi is {e:.2f}\".format(e=2.71828))&lt;&lt;&lt; 3.14&lt;&lt;&lt; 2.22&lt;&lt;&lt; 2.72 保留小数的依据是：四舍五入示例2：你可以使用 :&lt;、:&gt;、:^ 来设置文本的对齐方式，还可以使用数字来设置字段宽度。 123456789101112text = \"Hello\"formatted = \"{:&lt;10}\".format(text) # 左对齐print(f\"'{formatted}'\")formatted = \"{:&gt;10}\".format(text) # 右对齐print(f\"'{formatted}'\")formatted = \"{:^10}\".format(text) # 居中对齐print(f\"'{formatted}'\")&lt;&lt;&lt; 'Hello '&lt;&lt;&lt; ' Hello'&lt;&lt;&lt; ' Hello ' 其中10为整个范围的场宽,如果这个数字小于原本元素的宽度，比如小于hello的宽度5，就不会有影响f-string的使用是为了显示出两个单引号’’来表示它的场宽你也可以直接用一个数字来表示这个输出的宽度,不进行对齐 1234number = 42formatted = \"{:5}\".format(number)print(f\"'{formatted}'\")&lt;&lt;&lt; ' 42' 默认是右对齐 格式化数字的填充与符号 表示无论正数还是负数都显示符号：1234num1 = 42num2 = -42formatted1 = \"{:+}\".format(num1) # 输出 +42formatted2 = \"{:+}\".format(num2) # 输出 -42 表示仅在负数前显示符号，而正数不显示符号。实际上，这是默认的符号显示方式，所以即使省略 - 也会得到同样的效果。12formatted1 = \"{:-}\".format(num1) # 输出 42formatted2 = \"{:-}\".format(num2) # 输出 -42 （空格）表示在正数前显示一个空格，而负数显示 -。这种方式在对齐时很有用，因为正数会有一个占位空格，与负数对齐更整齐。 12formatted1 = \"{: }\".format(num1) # 输出 42 (42前空一个字节)formatted2 = \"{: }\".format(num2) # 输出 -42 填充 123456num = 42formatted = \"{:05}\".format(num) # 宽度为5，使用0填充 {:05}等价于{0&gt;5}print(formatted)&lt;&lt;&lt; 00042# formatted = \"{:0&lt;5}\".format(num) # 42000 数字左对齐,右填充# formatted = \"{:0^5}\".format(num) # 04200 居中,左右一起填充 除此之外 对于符号 比如+ - * . # 也可以填充,替换0即可 百分比格式化你可以通过 format 来格式化百分比数值，使用 :.2% 来指定保留两位小数的百分比。 1234percentage = 0.12345formatted = \"{:.2%}\".format(percentage)print(formatted)&lt;&lt;&lt; 12.35% 日期格式化12345from datetime import datetimenow = datetime.now()formatted = \"Current date and time: {:%Y-%m-%d %H:%M:%S}\".format(now)print(formatted)&lt;&lt;&lt; Current date and time: 2024-11-10 15:42:30 嵌套格式化你也可以在格式化字符串中进行嵌套，先使用一个表达式再进行格式化。 123formatted = \"{:,.2f}\".format(1234567.8910) # 这里 :, 用来添加千位分隔符，.2f 控制显示两位小数。print(formatted)&lt;&lt;&lt; 1,234,567.89 对应的f-string的功能用法12345678910111213141516171819202122# 数字格式化pi = 3.14159print(f\"The value of pi is {pi:.2f}\") # 填充和对齐text = \"Hello\"print(f\"'{text:&lt;10}'\") # 左对齐print(f\"'{text:&gt;10}'\") # 右对齐print(f\"'{text:^10}'\") # 居中对齐# 指定场宽num = 42print(f\"'{num:5}'\")# 日期格式化from datetime import datetimenow = datetime.now()print(f\"Current date and time: {now:%Y-%m-%d %H:%M:%S}\")# 百分比percentage = 0.12345print(f\"{percentage:.2%}\") 课本习题我们通过课本习题进行大多数内容讲解，建议看完课本剩余内容的基本定义然后根据题目的讲解进行理解因为没有标准答案，所以答案仅供参考 P14 Problem 1-7 D C D B D 12311+223311 22 33 123HelloWorld P14 Problem 8-121234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# Problem 8: 输入两个整数，输出它们的和def Problem_eight(): num1 = int(input(\"请输入第一个整数：\")) num2 = int(input(\"请输入第二个整数：\")) result = num1 + num2 print(f\"这两个整数的和是: {result}\")# Problem 9: 输入两个整数，输出这两个整数为高位和低位组成的整数def Problem_nine(): num1 = int(input(\"请输入第一个整数（高位）：\")) num2 = int(input(\"请输入第二个整数（低位）：\")) # 将两个数合并为一个整数 result = int(str(num1) + str(num2)) print(f\"组成的新整数是: {result}\")# Problem 10: 输出1+2+3+4+......+10的和def Problem_ten(): total = sum(range(1, 11)) print(f\"1到10的和是: {total}\")# Problem 11: 输出1*2*3*...*10的积def Problem_eleven(): total = 1 for i in range(1, 11): total *= i print(f\"1到10的积是: {total}\")# Problem 12: 以数字*作为基本要素输出\"ZJUT\"的图案def Problem_twelve(): # Z print(\"******** \") print(\" * \") print(\" * \") print(\"****** \") print(\" * \") print(\" * \") print(\"******** \") print() # J print(\" *** \") print(\" * \") print(\" * \") print(\" * \") print(\"* * \") print(\"* * \") print(\"******* \") print() # U print(\"* * \") print(\"* * \") print(\"* * \") print(\"* * \") print(\"* * \") print(\"* * \") print(\"********* \") print() # T print(\"********* \") print(\" * \") print(\" * \") print(\" * \") print(\" * \") print(\" * \") print(\" * \")print(\"请输入题号（8-12）来选择对应的题目：\")problem_number = int(input()) if problem_number == 8: Problem_eight()elif problem_number == 9: Problem_nine()elif problem_number == 10: Problem_ten()elif problem_number == 11: Problem_eleven()elif problem_number == 12: Problem_twelve()else: print(\"无效的题号。请输入一个有效的题号（8-12）。\") P53 Problem 2-10 A解析B ： 变量名不可用数字开头，通常用大小驼峰习惯进行命名，比如getNumber这种C : and是保留关键字，不可以命名D : 不可用特殊符号进行命名,下划线_除外 B解析A D : 不严谨,不纯粹C : 赋值左边是一个变量，不可以是一个表达式 D解析A B : 单双引号不影响，都是字符串类型C : 字符串类型，空字符串D : 复数类型 C解析指数运算，右结合(从右往左进行运算)2 ** 3 = 82 ** 8 = 256 D解析A : 字符串不能直接加数字ord函数：函数内填字符,返回字符所对应的ASCII码chr函数: 函数内填ASCII码，返回字符B : ord(‘D’) = 68,该选项得到67C : chr(65)返回字符’A’，不可与数字相加D : ord(‘B’) + 1 = 66 + 1 = 67,chr(67) = ‘C’ 正确 C解析A B : 分别得到第一个，第二个字符D : len(s) 返回字符串s的长度，超出索引,应该是len(s) - 1 B解析A : 返回’Pr’C : 返回’ro’D : 返回’rog’ C解析A B D : 返回’ab’C : 返回’aba’ D解析randint(10,99) 随机返回一个位于闭区间[10,99]的整数randrange(10,100) 随机返回一个位于左闭右开区间[10,100)的整数，步长为1randrange(10,100,2) 随机返回一个位于左闭右开区间[10,100)的整数，步长为2 即10 12 14 16 …… 96 98之一uniform(10,99) 随机返回一个位于闭区间[10,99]的浮点数 D : 返回的不是整数 BC解析A : 使用大小驼峰进行命名D : 可以使用中文名，但是不建议 P53 Problem 1112345678910111213# 引入数学模块import math# 输入球的半径r = float(input(\"请输入球的半径 r: \"))# 计算球的体积 V# math.pi 为 V = (4/3) * math.pi * r**3# 输出球的体积，保留四位小数# f-string格式化输入 {变量} 输出为变量所表示的值 .4f 保留四位小数print(f\"球的体积 V: {V:.4f}\") P53 Problem 12123456789101112131415import math# 输入三角形的两条边和夹角a = float(input(\"请输入边 a 的长度: \"))b = float(input(\"请输入边 b 的长度: \"))C = float(input(\"请输入夹角 C 的角度值: \"))# 将角度值转换为弧度值C_rad = math.radians(C)# 计算三角形的面积 math.sin()函数计算正弦值S = 0.5 * a * b * math.sin(C_rad)# 输出三角形的面积，保留四位小数print(f\"三角形的面积 S: {S:.4f}\") P53 Problem 13123456789101112# 引入calendar库import calendar# 输入年份和月份year = int(input(\"请输入年份: \"))month = int(input(\"请输入月份: \"))# 使用calendar.month()获取指定月份的日历month_calendar = calendar.month(year, month)# 输出指定的月份日历print(month_calendar) P74 Problem 1-7 B解析int类型中0为False，非0都为True字符串只有空串为False 其他为True C解析列表大小比较先比较长度，短的小长度一样从左往右依次比较对位元素，直到找到第一个可以比较大小的元素，停止，不看后面的元素比如此题1 3都相同开始比较下一个元素字符串字符串先比较长短，短的小长度相同开始从左往右比较各个字符的ASCII码 按大小比较c的ASCII码大于D 所以返回True 满足三目运算符,得3 D解析A B : Python也有类似C语言中的三目运算符 ? 但用法如下a = x if x &gt; y else y取两个值较大的一个C : if后跟冒号 改为if(x &gt; y): 或者 if x &gt; y : A解析x初始为0,在布尔类型下0对应Falsewhile x:循环条件为x，但一开始就为False无法进行 1234ZJUTZJUZJZ 解析while s 即理解为s不为空串就执行每一次更新s为它的子串0~length-1,也就是删掉最后一个元素 6. 1234=ZJUT=ZU==UU 解析 123s = s[1:] # 删去头部元素s = s[: : 2] # 隔一个取一个s = s[: :-1] # 字符串翻转 7.分行输出1 3 4 3解析else与j的for循环并列 : 如果j循环完全执行(即没有被break过),则进行elsecontinue不影响else的函数,但是会影响它下面的输出ij首先i = 1,j = 1,if和elif都不满足,执行print(ij),输出ij 也就是1然后i = 1,j = 2,满足elif的条件,跳过,不执行执行print(ij)此时i = 1时候j的循环完全执行,执行else里面的内容 执行print(i+j),输出i+j,此时j是循环到最后的值也就是2i+1,为2，输出1+2,即3然后i = 2,j = 1,满足elif 跳过然后i = 2,j = 2,不满足if和elif,执行print(ij)，输出4然后i = 2,j = 3,满足if条件,执行break函数跳出j的循环，因为没有运行完整该循环不执行else的内容然后i = 3,j = 1,不满足if和elif,执行print(ij)，输出3然后i = 3,j = 2,满足if条件,执行break函数,不执行else的内容i枚举完1~3,程序结束所以分行输出1 3 4 3 P75 Problem 8123456789101112131415161718# 引入随机数库import random# 生成两个随机的正整数number_one = random.randint(1, 100) # 生成 1 到 100 之间的随机整数number_two = random.randint(1, 100)# 计算它们的和total = number_one + number_two# 提示用户输入这两个数的和user_input = int(input(f\"请计算 {number_one} + {number_two} 的和: \"))# 判断用户输入是否正确if user_input == total: print(\"正确\")else: print(\"错误\") P75 Problem 9123456789101112131415import math# 输入x的值x = float(input(\"请输入x的值: \"))# 判断x的值，计算对应的y值if x &lt; 0: y = x**2 + 5 # ** 取幂运算elif 0 &lt;= x &lt; 10: y = math.sin(math.radians(x))**2 # 将x转换为弧度后计算sin(x)else: y = math.exp(x) - math.log(x) # exp(x)即为函数e^x,log(x)函数为ln(x)# 输出y的值，保留四位小数print(f\"y = {y:.4f}\") P75 Problem 10123456789101112131415import math# 输入三边a = float(input(\"请输入边 a 的长度: \"))b = float(input(\"请输入边 b 的长度: \"))c = float(input(\"请输入边 c 的长度: \"))# 判断是否能构成三角形if a + b &gt; c and a + c &gt; b and b + c &gt; a: s = (a + b + c) / 2 # 计算半周长 area = math.sqrt(s * (s - a) * (s - b) * (s - c)) # 计算面积 math.sqrt()函数为开方 print(f\"三角形的面积为: {area:.4f}\") # 输出三角形的面积else: # 如果不能构成三角形，输出提示信息 print(\"无法构成三角形\") P76 Problem 1112345678910111213141516171819202122232425# 定义一个子函数对秒数进行处理def convertTime(seconds): if seconds &gt;= 86400: # 大于一天 days = seconds // 86400 # 求天数，向下取整 seconds %= 86400 # 取模，得到除去天数剩下的秒数 hours = seconds // 3600 # 求小时数，向下取整 seconds %= 3600 # 取模，同上 minutes = seconds // 60 # 同上，后面不赘述 seconds %= 60 print(f\"{days}天{hours}小时{minutes}分钟{seconds}秒\") elif seconds &gt;= 3600: # 大于一小时 hours = seconds // 3600 seconds %= 3600 minutes = seconds // 60 seconds %= 60 print(f\"{hours}小时{minutes}分钟{seconds}秒\") elif seconds &gt;= 60: # 大于一分钟 minutes = seconds // 60 seconds %= 60 print(f\"{minutes}分钟{seconds}秒\") else: print(f\"{seconds}秒\")seconds = int(input(\"请输入秒数: \"))convertTime(seconds) P76 Problem 12123456def getZodiac(year): animals = [\"鼠\", \"牛\", \"虎\", \"兔\", \"龙\", \"蛇\", \"马\", \"羊\", \"猴\", \"鸡\", \"狗\", \"猪\"] return animals[(year - 2020) % 12] # 求出索引year = int(input(\"请输入年份: \"))print(f\"{year}年对应的生肖是:{getZodiac(year)}\") P76 Problem 13123456n = int(input(\"请输入整数 n: \"))ans = 1# 写一个循环,i从1到n range内为左闭右开区间for i in range(1, n + 1): ans *= iprint(f\"{n} 的阶乘是: {ans}\") P76 Problem 141234567891011121314151617181920212223242526import math# 求平均值 sum函数为求一个列表的和,len函数返回列表的元素个数def average(numbers): return sum(numbers) / len(numbers)# 求标准差 varience是方差def standardDeviation(numbers): n = len(numbers) # 求出元素个数 sum_xi = sum(numbers) # 计算所有数的和 sum_xi_squared = sum([x ** 2 for x in numbers]) # 计算所有数的平方和 variance = (sum_xi_squared - (sum_xi ** 2) / n) / (n - 1) # 计算样本方差 return math.sqrt(variance)# 输入多个数，用逗号分隔numbers_input = input(\"请输入多个数，用逗号分隔: \")# 将输入的字符串按逗号分隔，并转换为浮点数列表# split函数实现用,分隔开输入的元素，float转化为字符串numbers = [float(x) for x in numbers_input.split(',')]# 计算平均值和标准差avg = average(numbers)std_dev = standardDeviation(numbers)# 输出结果print(f\"平均值: {avg:.4f}, 标准差: {std_dev:.4f}\") P76 Problem 1512345678910111213141516# 定义一个子函数，来判断num是不是质数def isPrime(num): if num &lt; 2: # 0,1不是质数 return False for i in range(2, int(num ** 0.5) + 1): # 从2到根号num开始枚举 if num % i == 0: return False # 有一个数整除num,返回False ： 为合数 return True # 到最后都没有一个因子，返回True : 为质数def findPrimes(n): primes = [i for i in range(2, n + 1) if isPrime(i)] # 列表推导式,左边是数，右边是对数进行判断是不是质数 return primesn = int(input(\"请输入整数 n: \"))primes = findPrimes(n)print(f\"小于或等于 {n} 的素数有: {primes}, 总数为: {len(primes)}\") P76 Problem 161234567891011121314151617181920import mathdef calculateSeries(x): sumResult = 0 # 结果初始化为0 n = 1 # 从x^1开始 term = x # 第一项是x^1 / 1! sign = 1 # 第一项的符号是正 while abs(term) &gt;= 1e-5: # 直到项的绝对值小于10^-5 sumResult += term # 累加当前项 n += 2 # 下一项是 x 的下一个奇数次方 sign *= -1 # 符号交替 term = sign * (x**n) / math.factorial(n) # 计算下一项 return sumResult# 输入浮点数x = float(input(\"请输入浮点数 x: \"))# 计算并输出结果，保留六位小数result = calculateSeries(x)print(f\"计算结果: {result:.6f}\") P76 Problem 171234567891011121314151617import math# 角度列表angles = [0, 30, 60, 90, 120, 150, 180]# 打印表头print(f\"{'角度':&lt;10}{'sin':&lt;10}{'cos':&lt;10}{'tan':&lt;10}\")# 计算并打印每个角度的三角函数值for angle in angles: # 枚举属于角度列表的角度 radians = math.radians(angle) # 将角度转换为弧度 sin_value = math.sin(radians) # 计算正弦值余弦值和正切值 cos_value = math.cos(radians) tan_value = math.tan(radians) # 打印当前角度及其对应的三角函数值 print(f\"{angle:&lt;10}{sin_value:&lt;10.4f}{cos_value:&lt;10.4f}{tan_value:&lt;10.4f}\") P76 Problem 181234567891011def print_multiplication_table(): # 计算每个乘法表达式的最大长度 max_width = len(f\"9 * 9 = 81\") for i in range(1, 10): # 控制行数 for j in range(1, i + 1): # 每行的乘法表达式个数 # 使用字符串格式化控制宽度 print(f\"{j} * {i} = {i * j:2}\", end=\" \") # 换行 print()print_multiplication_table() P107 Problem 71234567891011# 输入10个数值，用空格隔开numbersList = list(map(int, input(\"请输入10个数值，用空格隔开：\").split()))# 计算平均数averageValue = sum(numbersList) / len(numbersList)# 找出大于平均数的所有数值greaterThanAverage = [num for num in numbersList if num &gt; averageValue]# 输出大于平均数的数值print(\"大于平均数的数值是:\", greaterThanAverage) P106 Problem 1-7 B解析A : 一个空元组C : 含有单个元素的元组D : 一个元组B : 整数1 D解析A. list.insert(index,number) 把number插入位置index 为[1,2,3,5]比如 a.insert(2,5) 就是插到第二个数后面,变为[1,2,5,3],(实际上是插到索引为2的位置，索引从0开始在第二个数后面)B. list.append(number) 把number插入末尾，括号里面只能一个数字(或者数对)比如 list.append((4,5)) 就是在末尾加入一个元组(4,5) 即[1,2,3,(4,5)]C. list.extend([number1,number2,….]) 将多个元素加入末尾这里非法了,应改为a.extend([4,5])如果要加入一个元组,这样 a.extend([(4,5)]) 变为[1,2,3,(4,5)] D解析[::-1] 切片操作，先翻转 (可以没有)[2] 找到索引为2的元素[1,2][1] 找到[1,2]中索引为1的元素,即2为2 A解析Python中元组和字符串是不可变的A : 第一个元素会变为[1,2,’X’] 是合法的B : add是集合set的用法，这里不能用C : 字符串不可变D : 元组不可变 [0, 2, 4, 6, 8][4, 6, 8, 0, 2][8, 6, 4, 2, 0][4, 6, 8, 0, 2]解析 123456789101112x = [i for i in range(0,10) if i % 2 == 0] #取出[0,10)中所有偶数print(x) # &gt;&gt;&gt; [0, 2, 4, 6, 8]for i in range(3): # 枚举0,1,2 t = x.pop() # 弹出最右边的元素8,并赋值给t x.insert(0,t) # 把t插入列表最左边 实际上就是进行了三次把最右边元素放到最左边的操作# [0,2,4,6,8] → [8,0,2,4,6] → [6,8,0,2,4] → [4,6,8,0,2]print(x) # [4,6,8,0,2]y = x # 让y地址为xz = x[:] # 让z等于字符串xx.sort(reverse=True) # 降序排序print(y) # 因为y的地址为x,x降序排序 所以y降序 [8,6,4,2,0]print(z) # 为for循环运行结束时x的字符串,没进行降序 [4,6,8,0,2] [83, 3, 86, 89][3, 83, 86, 89][83, 86][3]解析首先解释sort和sorted的区别sort : 只能用于列表,用法 a.sort(),修改原函数降序为a.sort(reverse = True)可以理解为一个操作,sort看成一个动词 sorted : 可以用于任何迭代对象,且不会修改原函数理解返回它的变化值,sorted看成一个形容词sorted_a = sorted(a, reverse=True) 降序排列操作，取a列表的降序顺序列表 123x = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]x.sort() # 对 x 进行排序print(x) # 输出 [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] 1234x = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]y = sorted(x) # 返回排序后的新列表print(x) # 输出原始列表 [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]print(y) # 输出排序后的新列表 [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] 123456789101112x = [86,89]a,b = x # a = 86,b = 89i = 0 while i &lt; 2: # 枚举i = 0 和 i = 1 a,b = b-a,a x.insert(0,a) # 插入元素 i = i + 1# a,b后面分别变为3,86和83,3 所以插入后x变为[83,3,86,89]print(x) # [83,3,86,89]print(sorted(x)) # 输出升序后的x [3,83,86,89]print(x[::2]) # x没变,对原列表切,步长为2 [83,86]print([n for n in reversed(x) if n % 3 == 0]) # reversed是翻转的x,找出被3整除的数,即为[3] reversed同样不会改变x原先的状态 P107 Problem 8123456789101112131415161718192021import random# 生成10个两位随机整数并放入列表aList = [random.randint(10, 99) for _ in range(10)] # 产生10个两位整数# 输出原列表print(\"原列表是:\", aList)# 获取用户输入的循环次数nn = int(input(\"请输入循环次数n：\"))# 确保n值不超过列表长度n = n % len(aList)# 执行右循环n次 list[a:b] 得到子列表a~b,不包含b# aList[-n:] 得到最后n个元素 aList[:-n] 得到前面的元素# 把最后n个元素放到剩下元素前面 实现后移aList = aList[-n:] + aList[:-n]# 输出循环后的列表print(\"循环后的列表是:\", aList) P107 Problem 91234567891011121314151617181920import math# 输入多个点的坐标，格式：x1 y1 x2 y2 x3 y3 ...coords = input(\"请输入多个点的坐标，格式为x1 y1 x2 y2 ...：\").split()# 将输入的坐标转化为浮点数，并按顺序存储为元组points = [(float(coords[i]), float(coords[i+1])) for i in range(0, len(coords), 2)]# 计算从原点(0, 0)开始，按顺序连接这些点的线段的总长度totalLength = 0# 从原点到第一个点的距离x0, y0 = 0, 0 # 原点for x, y in points: distance = math.sqrt((x - x0)**2 + (y - y0)**2) totalLength += distance # 加上距离 x0, y0 = x, y # 更新当前点的位置# 输出总长度，保留两位小数print(f\"从原点开始按顺序连接这些点的总长度为: {totalLength:.2f}\") P107 Problem 10123456789101112131415161718import math# 用户输入数据个数n = int(input(\"请输入数据个数n：\"))# 用户输入n个浮点数data = list(map(float, input(\"请输入n个浮点数，用空格隔开：\").split()))# 计算平均值average = sum(data) / n# 计算标准差（近似标准差）variance = sum((x - average) ** 2 for x in data) # 列表推导式枚举xstandardDeviation = math.sqrt(variance / (n - 1))# 输出平均值和标准差，保留两位小数print(f\"平均值: {average:.2f}\")print(f\"标准差: {standardDeviation:.2f}\") P107 Problem 11123456789101112131415161718192021222324252627def main(): students = [] # 持续接收输入，直到输入\"OVER\" while True: userInput = input(\"请输入学号和成绩，用空格隔开（输入OVER结束）：\") if userInput == \"OVER\": break #如果输出OVER 结束程序 # 分割学号和成绩 studentInfo = userInput.split() # 读入学生信息为一个列表 studentId = int(studentInfo[0]) # 学号 score = float(studentInfo[1]) # 成绩 # 判断成绩是否及格 if score &gt;= 60: students.append((studentId, score)) # 及格学生列表加入学生学号和成绩 # 按学号升序排序 students.sort(key=lambda student: student[0]) # 用sort函数按照学号进行排序 # 输出结果 print(\"\\n考试及格的学生名单：\") for student in students: print(f\"学号: {student[0]}, 成绩: {student[1]:.2f}\")main() P107 Problem 12123456789101112131415161718def main(): students = [] while True: userInput = input(\"请输入学号和成绩，用空格隔开（输入OVER结束）：\") if userInput == \"OVER\": break studentInfo = userInput.split() studentId = int(studentInfo[0]) score = float(studentInfo[1]) if score &gt;= 60: students.append((studentId, score)) students.sort(key=lambda student: student[1], reverse=True) # reverse = True 降序排列 print(\"\\n考试及格的学生名单：\") for student in students: print(f\"学号: {student[0]}, 成绩: {student[1]:.2f}\")main() 上机实验本实验题目解析不再赘述,仅给出答案需要学习具体用法可以参考课本习题，大多数用法已经介绍过实验课题目仅给出代码 实验11234567891011121314151617181920212223242526272829303132333435363738394041# 1a = input(\"输入一个地名：\")b = input(\"输入一个人名：\")print(a+\"很美,\"+b+\"想去看看\")# 2month=\"JanFebMarAprMayJunJulAugSepOctNovDec\"index=int(input(\"请输入月份：\"))print( str(index)+\"月的月份简写是\" + month[index*3-3]+month[index*3-2]+month[index*3-1])# 3nums=[34,5,89,3,32,122]print(\"一组数：%s\"%nums)sum=0for i in nums: sum=sum+ires=sum/len(nums)print(\"{:.3f}\".format(res))# 4inp=input(\"请输入三个字符用逗号分隔：\")lis=inp.split(\",\")orilis=lisif lis[0]&gt;lis[1]: lis[1]=lis[2]else: lis[0]=lis[2]if lis[0]&gt;lis[1]: res=lis[0]else: res=lis[1]print(orilis[0]+\",\"+orilis[1]+\",\"+orilis[2]+\"中最大的字符是\"+res)# 5import mathx1 = int(input(\"请输入x1的值: \"))x2 = int(input(\"请输入x2的值: \"))y1 = int(input(\"请输入y1的值: \"))y2 = int(input(\"请输入y2的值: \"))s = math.sqrt(pow(y2 - y1,2) + pow(x2 - x1,2)) # sqrt()开根 pow()取幂print(\"%.2f\"%s) 实验2-11234567891011121314151617import random # 随机数库c = 5while c &gt; 0: c = c - 1 # 运行5次 ch = chr(random.randint(97, 122)) # ASCII码的范围为a,z print(ch * 3, end=\" \") # *3 重复三个 end=\" \" 间隔一个空格print(\"\")c = 5while c &gt; 0: c = c - 1 chc = random.randint(3, 5) # 长度为3-5 随机 while chc &gt; 0: chc = chc - 1 print(chr(random.randint(97, 122)), end=\"\") # 随机生成a-z的字母 print(\" \", end=\"\") 实验2-2123456789101112131415inp=input(\"请输入一个三位整数：\")err=Falsetry: inp=int(inp) if inp&gt;999 or inp&lt;=100: # 范围卡在三位数 err=Trueexcept: err=Trueif err: print(\"请输入一个正确的三位整数！\")else: if inp//100==inp%10: # 第一位和第三位 print(inp,\"是一个对称的三位数\") else: print(inp,\"不是一个对称的三位数\") 实验2-3三种方法 123456789101112inp = input(\"请输入一个三位数：\")err = Falsetry: inp = int(inp) if inp &gt; 999 or inp &lt; 100: err = Trueexcept: err = Trueif err: print(\"警告：输入数据有误，请输入一个三位数！\")else: print(str(inp % 10) + str((inp % 100) // 10) + str(inp // 100)) # 取出三位数，然后倒序连接 12345678910111213inp = input(\"请输入一个三位数：\")err = Falsetry: inp = int(inp) if inp &gt; 999 or inp &lt; 100: err = Trueexcept: err = Trueif err: print(\"警告：输入数据有误，请输入一个三位数！\")else: inp = str(inp) print(inp[2] + inp[1] + inp[0]) # 根据索引顺序倒序连接 123456789101112131415inp = input(\"请输入一个三位数：\")err = Falsetry: inp = int(inp) if inp &gt; 999 or inp &lt; 100: err = Trueexcept: err = Trueif err: print(\"警告：输入数据有误，请输入一个三位数！\")else: inp = str(inp) inp = list(inp) inp.reverse() print(\"\".join(inp)) 实验2-412345678910import randomimport stringhead = random.choice(string.ascii_uppercase)tail =''.join(random.choices(string.ascii_letters + string.digits, k=7))password = head + tailprint(password)if any(char.isdigit() for char in password): print(password)else: print(\"密码无效！\") 实验3-112345678910111213141516171819202122232425import mathdef work(x): if x &lt; 0: y = abs(x) elif 0 &lt;= x &lt; 5: y = math.cos(math.radians(x)) * math.exp(x) # 三个函数 余弦值 弧度值 e^x函数 elif 5 &lt;= x &lt; 10: y = x ** 3 else: y = (7 + 8 * x) * math.log(x) return ydef main(): x_input = input(\"请输入一个数x：\") try: x = float(x_input) y = work(x) if y.is_integer(): print(f\"y = {int(y)}\") else: print(f\"y = {y:.2f}\") except ValueError: print(\"请输入有效的数字\")main() 实验3-2123456789101112131415161718192021222324252627def One(a, b, c): if a &gt;= b and a &gt;= c: # a最大 return a elif b &gt;= a and b &gt;= c: # b最大 return b else: # a,b都不是最大，那么c最大 return cdef Two(a, b, c): max_value = a # 假定a最大,此时最大值为max_value if b &gt; max_value: # 如果b大于此时的最大值,更新最大值为b max_value = b if c &gt; max_value: # 同理如果c大于更新后的最大值，继续更新 max_value = c return max_value def max_of_two(x, y): return x if x &gt; y else y # 三目运算符返回两个数的最大值def Three(a, b, c): return max_of_two(max_of_two(a, b), c) # 返回a,b的最大值,然后返回max(a,b)和c的最大值def main(): a, b, c = map(int, input(\" \").split()) max_one = One(a, b, c) max_two = Two(a, b, c) max_three = Three(a, b, c) print(max_one, max_two, max_three)main() 实验3-312345678910111213141516171819202122232425262728def number_to_words(num): number_words = { 0: 'zero', 1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six', 7: 'seven', 8: 'eight', 9: 'nine' } return number_words.get(num, '') def main(): user_input = input(\"请输入一串数字：\") result_words = [] for char in user_input: if char.isdigit(): num = int(char) - 1 if num &lt; 0: num = 0 result_words.append(number_to_words(num)) else: print(\"请输入有效的整数\") return print(' '.join(result_words))main() 实验3-412345678910111213141516171819202122232425262728def is_hui(s): return s == s[::-1] # s[::-1]为翻转字符串 判断翻转前后是否一致 # 一致返回True 否则返回Falsedef is_shui(num): num_str = str(num) n = len(num_str) total = sum(int(digit) ** n for digit in num_str) return total == num def main(): hui_input = input(\"请输入一个字符串\") if is_hui(hui_input): print(f\"{hui_input} 是一个回文字符\") else: print(f\"{hui_input} 不是一个回文字符\") shui_input = input(\"请再次输入一个整数\") if shui_input.isdigit(): shui_num = int(shui_input) if is_shui(shui_num): print(f\"{shui_num} 是水仙花数\") else: print(f\"{shui_num} 不是水仙花数\") else: print(\"请输入有效的整数\")main() 实验3-51234567891011121314151617181920212223242526def work(sum): if 100 &lt;= sum &lt; 300: percent = 0.98 elif 300 &lt;= sum &lt; 500: percent = 0.90 elif sum &gt;= 500: percent = 0.88 else: percent = 1.00 ans = sum * percent discount_amount = sum - ans return ans, discount_amountdef main(): total_price_input = input(\"请输入商品总价：\") try: sum = float(total_price_input) ans, discount_amount = work(sum) print(f\"需要支付价格为{ans:.2f}元，优惠{discount_amount:.2f}元\") except ValueError: print(\"请输入有效的数字\")main() 实验4-112345678910111213141516171819202122232425262728def solve_one(): ans = 0 for i in range(1,1001): if i % 10 == 0 : continue else : ans+=i print(ans)def solve_two(): number_list = [i for i in range(1,1001) if i % 10 != 0] print(sum(number_list))def flag(x): return x % 10 != 0def solve_three(): ans = sum(filter(flag,range(1,1001))) print(ans)def solve_four(): # filter(lambda x: condition, iterable) # condition: 条件表达式或者一个布尔值 # lterable : 一个数据序列,x为从中取出的值 ans = sum(filter(lambda i : i % 10 != 0,range(1,1001))) print(ans)solve_one()solve_two()solve_three()solve_four() 实验4-2本题题意有歧义，这里理解为多次输入 123456789import randomnumber_one = random.randint(1,10)number_two = random.randint(1,10)if number_two &gt; number_one: # 令number_one为较大的一个 number_one,number_two = number_two,number_onea = int(input(f\"What is {number_one} - {number_two} =\"))while a != number_one - number_two: a = int(input(f\"Wrong! What is {number_one} - {number_two} = \"))print(\"You Got It\") 实验4-3123456789x = float(input(\"请输入x的值: \"))total = 0.0 now = 1.0 index = 0 while abs(x / now) &gt; 1e-5: #1e-5 为10^(-5) total += pow(x, index) / now #index为n的值,now为n! index += 1 # 更新index和now now *= index print(total) 实验4-4辗转相除法 1234567891011# gcd()在math库里有，可以引入后直接使用# 这里介绍下原理：辗转相除法def gcd(a,b): while b: a,b = b,a % b return int(a)def lcm(a,b): # 最小公倍数等于两数和除以最大公约数 return int(a * b / gcd(a,b))numbers = (input(\"请输入两个数:\"))number_one,number_two = map(int,numbers.split())print(f\"最大公因数为{gcd(number_one,number_two)};最小公倍数为{lcm(number_one,number_two)}\") 实验4-512345678910111213141516171819202122232425262728def solve_one(x): arr = [] for i in range(1,x + 1): temp = str(x) * i # 求出x个长度为i的字符串iiiii...... arr.append(temp) # 加到队列中 total = ' + '.join(arr) # 把队列中的这些字符串类型的数字用\"+\"连接 print(eval(total)) # eval 对加号\"+\"进行运算def solve_two(x): arr = [] for i in range(1,x + 1): temp = int(str(x) * i) # 同上求出数字串,但是转换为整数型 arr.append(temp) print(sum(arr)) # 直接sum函数求和def solve_three(x): total = sum(int(str(x) * i) for i in range(1,x + 1)) # 解法2的列表推导式 print(total)def solve_four(x): total = sum(map(lambda i : int(str(x) * i) ,range(1,x + 1))) print(total)number = int(input(\"请输入a:\"))solve_one(number)solve_two(number)solve_three(number)solve_four(number) 实验4-61234567891011121314151617181920212223242526def GetPrimes(n): # 欧拉筛 is_prime = [True] * (n + 1) # 把所有的元素都初始化为\"是一个素数\" primes = [] # 存储素数 for i in range(2,n + 1): if is_prime[i] : primes.append(i) # 如果这个数不是素数,加到列表里面 for j in range(i * 2, n + 1, i): # 枚举i的小于n的正整数倍数 is_prime[j] = False # i的倍数都是合数,标记为非负数 return primes # 返回素数列表def main(): n = int(input(\"请输入一个整数N:\")) origin_n = n primes = GetPrimes(n) # 得到2-n范围内的素数列表 AnswerArr = [] # 存储答案 temp = 0 # 索引 while n &gt; 1: while(n % primes[temp] == 0 and n): # 如果n整除该素数 除以它 n //= primes[temp] AnswerArr.append(primes[temp]) # 把该素数加到答案列表中 temp+=1 # 如果n不能整除该素数了,索引+1,继续枚举后续素数 if AnswerArr[0] == origin_n : # 如果答案的第一位和原数相等,说明本身就是素数 print(f\"1 * {origin_n}\") else : # 如果是合数,用*连接它的质因子 print(' * '.join(map(str,AnswerArr)))main() 实验5-112345678910111213141516userInterests = { 'Alice': ['music', 'reading', 'movies'], 'Bob': ['sports', 'movies'], 'Charlie': ['reading', 'movies', 'coding']}commonInterests = set(userInterests['Alice']) &amp; set(userInterests['Charlie']) # 取交集print(f\"Alice 和 Charlie 的共同兴趣: {commonInterests}\") # 输出共同兴趣targetUser = 'Alice' # 找Alice的朋友，可以改成其他已有名字，也可以改成交互式输入一个字符串名字targetInterests = set(userInterests[targetUser]) # 把该人的兴趣取一个集合friends = [] # 存储朋友名单for user, interests in userInterests.items(): # 枚举姓名和兴趣 if user != targetUser: isCommon = targetInterests &amp; set(interests) # 一一取交集 if isCommon: # 如果交集不为空（有共同兴趣） friends.append((user)) # 加到朋友名单里面print(f\"给 Alice 推荐的好友: {friends}\") 实验5-212345678910salaries = {} # 存储所有信息userName = str(input(\"请输入员工姓名(需要停止请输入Stop):\"))while userName!='Stop': userSalary = float(input(\"请输入该员工薪资:\")) salaries[userName] = userSalary # 添加键值对 姓名-薪资 userName = str(input(\"请输入员工姓名(需要停止请输入Stop):\"))for tempName,salary in salaries.items(): # 枚举姓名和薪资 salaries[tempName] = salary * 1.1 # 把姓名对用的值改为其1.1倍for Name,newSalary in salaries.items(): # 枚举姓名和新的薪资 print(\"调整后{0}的薪资为:{1:.2f}\".format(Name,newSalary)) # format输出姓名和新的薪资，保留2位小数 实验5-312345678910111213141516filmScore = {} # 电影名-打分的键值对filmName = str(input(\"请输入电影名称(需要停止请输入Stop):\"))while filmName!='Stop': scoreList = list(map(int,input(\"请输入评分:\").split(','))) filmScore[filmName] = scoreList filmName = str(input(\"请输入电影名称(需要停止请输入Stop):\"))maxScore = float(-1) # 最高分数maxName = '' # 最高分数对应的电影名称for name,score in filmScore.items(): # 枚举电影名和打分 filmScore[name] = sum(score)/len(score) # 计算,更新键对应的值位平均分数 用sum和len求平均 if filmScore[name] &gt; maxScore: # 如果该电影平均分数大于最高分数 maxName = name # 更新最高分数对应的电影名称为该电影的名称 maxScore = filmScore[name] # 同时维护一个最高分数for name,score in filmScore.items(): # 枚举所有电影名-平均分的键值对并输出 print(f\"电影{name}的平均评分为{score}\")print(f\"评分最高的电影是{maxName},它的分数为{maxScore}\") # 输出最高电影的名称和它的分数 实验5-41234567891011121314151617181920212223informationInput = eval((input(\"请输入个人银行信息（'Stop停止'）：\"))) # eval来解析输入,更方便一点informationList = [] # 存储所有的个人信息nobelList = [] # 存储金额大于1000的名单while informationInput != 'Stop': # 注意输入的'Stop'要带引号,否则eval会报错 informationList.append(informationInput) # 把个人信息添加到总信息名单里面 informationInput = eval((input(\"请输入个人银行信息（'Stop停止'）：\")))for i in range(0,len(informationList)): # 按照索引枚举信息名单# 列表的每一项存储的是元组 例如 ('Alice', 1200, [200, -100, 50, -10, 300]) [i]表示第i个人 newMoney = informationList[i][1] + sum(informationList[i][2]) # [i][1]表示第i个人的第2个元组元素，也就是余额，对应上面的1200 [i][2]表示一个列表（交易记录） informationList[i] = informationList[i] + (newMoney,)# 元组不可改，用替代的方式实现增删改 新元组 = 老元组 + 要添加的元素(元素,) if informationList[i][3] &gt; 1000: # [i][3] 对应上面添加的元素，也就是交易后的余额 nobelList.append(informationList[i][0]) # [i][0]表示第i个人的姓名，添加到大于1000名单print(\"下面余额大于1000元的账户：\",end = '')for name in nobelList: # 枚举&gt;1000的姓名 print(name,end = ' ')print('')for individual in informationList: # 直接枚举元素 [0]:姓名 [1]:老余额 [2]:交易记录 [3]:新余额 print(f\"账户姓名：{individual[0]};账户余额：{individual[3]};交易记录:{individual[2]}\")# 至于为什么这里是只有一个[],因为这里获取的是informationList中的元素,individual相当于('Alice', 1200, [200, -100, 50, -10, 300])等# 而informationList[0] 才相当于 ('Alice', 1200, [200, -100, 50, -10, 300]) 所以需要二维索引# 如果这里改成 for i in (0,len(informationList)) 则枚举的是索引 需要用到二维索引","categories":[],"tags":[{"name":"本科教学知识","slug":"本科教学知识","permalink":"https://fufffh.github.io/tags/%E6%9C%AC%E7%A7%91%E6%95%99%E5%AD%A6%E7%9F%A5%E8%AF%86/"}],"author":"Fufffh"},{"title":"C++中的常见运算符","slug":"C-中的常见运算符","date":"2024-10-27T14:39:29.000Z","updated":"2024-10-28T15:19:00.222Z","comments":true,"path":"2024/10/27/C-中的常见运算符/","permalink":"https://fufffh.github.io/2024/10/27/C-%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E8%BF%90%E7%AE%97%E7%AC%A6/","excerpt":"","text":"算数运算符 加减乘除 + - * / 1234int sum = a + b;int sum = a - b;int sum = a * b;int sum = a / b; // int除法默认向下取整 取模运算 % 1int p = a % b; 理解为做除法得到的余数,例如7 &#x2F; 2 &#x3D; 3……1,1 &#x3D; 7 % 2 赋值运算符 直接赋值 = 1int a = 1; 令a的值为1 复合赋值 += -= *= /= 1234x += 3; // 等价于 x = x + 3x -= 2; // 等价于 x = x - 2x *= 4; // 等价于 x = x * 4x /= 2; // 等价于 x = x / 2 比较运算符== != &gt; &lt; &gt;= &lt;= 123456789101112131415等于 (==)：判断两个值是否相等。if (a == b) &#123; /* ... */ &#125;不等于 (!=)：判断两个值是否不相等。if (a != b) &#123; /* ... */ &#125;大于 (&gt;)：判断左侧值是否大于右侧值。if (a &gt; b) &#123; /* ... */ &#125;小于 (&lt;)：判断左侧值是否小于右侧值。if (a &lt; b) &#123; /* ... */ &#125;大于等于 (&gt;=) 和 小于等于 (&lt;=)：if (a &gt;= b) &#123; /* ... */ &#125;if (a &lt;= b) &#123; /* ... */ &#125; 逻辑运算符&amp;&amp; || ! 12345678与 (&amp;&amp;)：当且仅当两个操作数都为真时，结果为真。if (a &gt; 0 &amp;&amp; b &gt; 0) &#123; /* ... */ &#125;或 (||)：只要有一个操作数为真，结果就为真。if (a &gt; 0 || b &gt; 0) &#123; /* ... */ &#125;非 (!)：取反操作符，返回布尔值的相反值。if (!isValid) &#123; /* ... */ &#125; 位运算符 按位与&amp;对两个数在二进制下进行与运算，只有对应位都为1时结果才为1123int a = 13; // 二进制：1101int b = 11; // 二进制：1011int result = a &amp; b; // result 为 9，二进制：1001 按位或|对两个数在二进制下进行或运算，只要对应位与自身有一个为1，结果就为1123int a = 5; // 二进制：0101int b = 3; // 二进制：0011int result = a | b; // result 为 7，二进制：0111 按位异或^对两个数在二进制下进行异或运算，当对应位不同时（一个为1一个为0）结果为1123int a = 5; // 二进制：0101int b = 3; // 二进制：0011int result = a ^ b; // result 为 6，二进制：0110 左移&lt;&lt;将一个数的二进制数向左移动指定的位数，右侧补012int a = 5; //二进制：0101int result = a &lt;&lt; 1; // result 为 10，二进制：1010，相当于 a * 2 右移&gt;&gt;将一个数的二进制数向右移动指定的位数，右侧补012int a = 5; //二进制：0101int result = a &gt;&gt; 1; // result 为 2，二进制：0010，相当于 a / 2 (向下取整) 三目运算符?: 根据条件不同返回不同的值 12int result = (a &gt; b) ? a : b; // 如果 a 大于 b，则 result 为 a，否则为 b?前为一个布尔型变量进行真假判断，为真返回:前面的值，为假返回:后面的值 指针运算符 地址运算符 &amp;获取变量的地址12int x = 10;int* ptr = &amp;x; // ptr 指向 x 的地址 解引用运算符*访问指针所指向的变量的值1234int x = 10;int* ptr = &amp;x; // ptr 指向 xint value = *ptr; // value 为 10，解引用 ptr 获取 x 的值*ptr = 20; // 将 x 的值改为 20 指针的自加或自减++ --1234int arr[] = &#123;1, 2, 3, 4&#125;;int* ptr = arr; // ptr 指向数组的首元素ptr++; // 现在 ptr 指向 arr[1]int second = *ptr; // second 为 2 其他运算符 自增++将变量加1 12x++; // 后缀自增++x; // 前缀自增 这里我们这样理解，一个是执行完之后自增，一个是先自增再执行 1234int a = 5;int b = a++; //b = 5,a = 6;int a = 5;int b = ++a; //b = 6,a = 6; 所以我们定义一个cnt记录数组长度时，经常这样，cnt即为数组长度 12int cnt = 0;a[++cnt] = number; 当然你也可以这样，前后同一索引代表的元素一样，不过这里cnt-1为数组长度 12int cnt = 1;a[cnt++] = number; 自减少-- 12x--; // 后缀自减--x; // 前缀自减","categories":[],"tags":[{"name":"基础知识","slug":"基础知识","permalink":"https://fufffh.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"author":"Fufffh"},{"title":"树状数组","slug":"树状数组","date":"2024-10-27T13:57:52.000Z","updated":"2024-10-28T15:19:08.376Z","comments":true,"path":"2024/10/27/树状数组/","permalink":"https://fufffh.github.io/2024/10/27/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","excerpt":"","text":"","categories":[],"tags":[{"name":"数据结构——进阶","slug":"数据结构——进阶","permalink":"https://fufffh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%BF%9B%E9%98%B6/"}],"author":"Fufffh"},{"title":"并查集","slug":"并查集","date":"2024-10-26T12:00:48.000Z","updated":"2024-10-28T15:19:20.151Z","comments":true,"path":"2024/10/26/并查集/","permalink":"https://fufffh.github.io/2024/10/26/%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"什么是并查集？并查集（Union-Find）是一种数据结构，主要用于处理动态连通性问题。它支持高效的合并（Union）和查询（Find）操作，常用于解决图的连通性、集合的合并等问题。通过并查集，我们可以将两个（或多个）元素合并到一个集合中，并查询两个元素是否同属一个集合。我们通过数组来实现这个操作 代码示范指的是第i个元素的祖宗（可以理解为一个集合中的祖宗，代表这个集合）一开始认为所有点都是孤立的一个集合，每个元素的祖宗就是它本身 1234int fa[MAXN];...... for(int i = 1; i &lt;= n; i++) fa[i] = i; 找祖宗的操作，如果一个节点的祖宗不是它本身,那么继续递归，直到一个元素的祖宗为自身（祖宗元素），返回集合的祖宗 12345int find(int x){ if(fa[x] == x) return fa[x]; return find(fa[x]);} 下面是合并操作，如果两个元素a、b不是同一个祖宗，那么将a的祖宗的直系父亲设为b后续find(a)操作递归过程中会变为find(b)的找b祖宗的过程 123456789for(int i = 1 ;i &lt;= m; i++){ int a,b; scanf(\"%d%d\",&amp;a,&amp;b); a = find(a); b = find(b); if(a!=b) fa[a] = b;} 当然你也可以把合并操作写到一个子函数里面 12345678void join(int a,int b){ int f1 = find(a); int f2 = find(b); if(f1!=f2) fa[f1] = f2;}...... join(a,b); 模板题https://www.luogu.com.cn/problem/P1551https://www.luogu.com.cn/problem/P3367这是两道模板题，大家可以前往自己进行代码自测。上述已经给出了合并与寻找的操作，这里只给出一个查询两元素是否同集合的伪代码 12345678910for(int i = 1; i &lt;= p; i++){ int a,b; scanf(\"%d%d\",&amp;a,&amp;b); a = find(a); b = find(b); if(a == b) printf(\"Yes\\n\"); else printf(\"No\\n\");} CF 970 (Div. 3) Problem D题目来源：https://codeforces.com/contest/2008/problem/D或者点击此处前往洛谷自测 题目描述 对于某个排列 ： 如果可以通过赋值 一定次数使 等于 ，则樱子称整数 可以从整数 到达。例如，如果 ，那么，举例来说， 可以从 到达，因为 现在是 ，所以 可以从 到达。 排列中的每个数字都被染成黑色或白色。 樱子将函数 定义为从 可以到达的黑色整数的个数。 樱子对每个 的 都很感兴趣，但计算所有值变得非常困难，因此她请你作为她的好朋友来计算这个值。 长度为 的排列是由 个不同的整数组成的数组，这些整数从 到 按任意顺序排列。例如， 是一个排列，但 不是一个排列（数字 在数组中出现了两次）， 也不是一个排列（ ，但数组中包含 ）。 输入格式 第一行包含一个整数 ( ) — 测试用例数。 每个测试用例的第一行包含一个整数 ( ) — 测试用例中的元素个数。 每个测试用例的第二行包含 个整数 ( ) — 排列元素。 每个测试用例的第三行包含一个长度为 的字符串 ，由 ‘0’ 和 ‘1’ 组成。如果 ，那么数字 被涂成黑色；如果 ，那么数字 被涂成白色。 保证所有测试用例中 的总和不超过 。 输出格式 对于每个测试用例，输出 个整数 。 样例输入 12345678910111213141516511051 2 4 5 31010155 4 1 3 21001163 5 6 1 2 401000061 2 3 4 5 6100110 样例输出 123451 0 1 1 1 1 2 2 2 2 2 4 1 4 4 1 4 0 1 1 0 0 1 思路：本题目实际上就是找到每个元素所在集合的元素的个数我们令表示自然数序号,表示第个数的值每次合并 我们定义一个数组is,表示第i个元素所在集合的黑色块的个数。 前提i为一个集合的祖宗如果s[i] == 0,因为此时所有点还是孤立的（一个点代表一个集合————for(int i = 1; i &lt;= n; i++) fa[i] = i）所以a[i+1]所在集合的黑色块个数为1（它本身） 12345678 int is[200001]; ...... cin&gt;&gt;s; memset(is,0,sizeof(is)); //is默认都为0 for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i];for(int i = 0; i &lt; s.size(); i++) //string索引从0开始 if(s[i]=='0') is[a[i+1]] = 1; //针对string索引从0开始，数组从1开始，数组索引加1 //因为输入的是a[i],所以令is[a[i+1]] = 1 下面进行合并集合的操作，如果两个数、属于两个集合，那么合并后两个集合的黑色块个数相加这里定义f2为合并后的祖宗节点，is[f2]代表合并后集合的黑色块总数 然后按照题意合并 123456789101112void join(int c1,int c2){ int f1 = find(c1),f2 = find(c2); if(f1!=f2) { fa[f1] = f2; is[f2] += is[f1]; }}......for(int i = 1; i &lt;= n; i++) join(i,a[i]); 最后我们只需要输出每个点所在集合的黑色块个数，也就是找到它的祖宗——find(i)，然后is(find(i))即为所求 1for(int i = 1; i &lt;= n; i++) cout&lt;&lt;is[find(i)]&lt;&lt;\" \"; 接下来给出整道题的全部代码 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;bits/stdc++.h&gt;using namespace std;int fa[200001];int is[200001];int find(int x){ if(x==fa[x]) return x; return fa[x] = find(fa[x]);}void join(int c1,int c2){ int f1 = find(c1),f2 = find(c2); if(f1!=f2) { fa[f1] = f2; is[f2] += is[f1]; }}int main(){ int t; cin&gt;&gt;t; while(t--) { memset(is,0,sizeof(is)); int n; cin&gt;&gt;n; string s; int a[n+1]; for(int i = 1; i &lt;= n; i++) fa[i] = i; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; cin&gt;&gt;s; for(int i = 0; i &lt; s.size(); i++) if(s[i]=='0') is[a[i+1]] = 1; for(int i = 1; i &lt;= n; i++) join(i,a[i]); for(int i = 1; i &lt;= n; i++) cout&lt;&lt;is[find(i)]&lt;&lt;\" \"; cout&lt;&lt;endl; } return 0;}","categories":[],"tags":[{"name":"数据结构——入门","slug":"数据结构——入门","permalink":"https://fufffh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"}],"author":"Fufffh"},{"title":"堆（heap）","slug":"堆（heap）","date":"2024-10-26T11:57:03.000Z","updated":"2024-10-28T15:18:12.177Z","comments":true,"path":"2024/10/26/堆（heap）/","permalink":"https://fufffh.github.io/2024/10/26/%E5%A0%86%EF%BC%88heap%EF%BC%89/","excerpt":"","text":"前置知识：注意：实现堆需要用到完全二叉树的知识，如果未学习，点击了我也没用，因为我还没写 什么是堆？堆（heap），又叫二叉堆，是一种基于完全二叉树实现的数据结构，它可以实现在堆顶的元素是整个堆里面最大的元素（大根堆），也可以是最小的元素（小根堆），进而获取到整个仪器中的最值的一种数据结构。通过它，我们可以快速获取一组数据中的最值，它的时间复杂度只有O(logn),堆同时也支持删除操作，不过它只能删除堆顶。 图解示范首先我们先看完全二叉树的节点序号如下，可以发现一个父节点和子节点序号的关系：设父节点序号为x,那么左子节点的序号为2x，右子节点的序号为2x+1我们同时也可以知道一个节点x的父节点序号为x/2,（右子节点也是，因为int类型除以2默认向下取整） 首先给出一个堆（这里我们以大根堆为例） 12int w[MAXN];int tot; //当前堆中节点的个数 对于插入操作假如我们插入一个5，我们将其插到数组的最后，作为叶子节点。 如果此时插入的子节点大于其父节点的值，违背了大根堆的性质，那么我们需要堆二叉堆进行修复(modify)操作即向上比较，如果其大于父节点的值，那么便交换两者的位置. 因为5 &gt; 1 所以与其父节点进行位置交换，然后接着进行修复操作，继续向上比较大小 5 &gt; 4,继续与父节点进行位置交换，然后接着向上进行比较，发现小于它的父节点，所以停止修复可见整个修复过程是相对二叉堆来讲自下而上的修复。 接着我们来讲删除堆顶的操作，首先我们无法直接删除堆顶，否则二叉堆会分裂为两棵树，修复麻烦巨大。所以我们寻找一种合适的做法：先把堆顶和堆尾（数组的最后一个数）交换位置 然后我们将交换过去的堆顶在队尾删除。接着我们发现堆顶的元素是一个较小（甚至最小）的数，违背了大根堆的原则，我们又需要对二叉堆进行修复(repair)相对于前者的插入修复，这里的删除修复是一种自上而下的修复。首先比较两个子节点的大小，接着父节点与子节点中较大的一个进行大小的比较，如果小于其中较大的节点，对二者进行交换。选择其中较大的子节点是为了确保如果进行交换，交换上去的子节点是一个更大的数，这样满足大根堆的性质。此处,进行修复（交换0和7），然后接着向下判断 ,进行修复（交换0和6） 每一步也都要对修复的过程进行判断，如果已经是叶子节点（2x &gt; tot） 那么停止修复，这里满足的就是这种情况如果出现父节点的值大于两个子节点的值，也停止修复。 这样，我们就完成了删除堆顶操作的修复操作。 代码示范访问堆顶，很简单，根节点（1）即为最大值 1234int top(){ return w[1];} 修复到的节点序号为x,如果修复过程中x已经是根节点(x == 1)，或者大于其父节点w[x] &lt; w[x/2] 回溯否则，交换x与父节点的值，然后接着向上递归修复。 1234567891011void modify(int x){ if(x == 1 || w[x] &lt; w[x/2]) return; swap(w[x],w[x/2]); modify(x/2);}void push(int x){ w[++tot] = x; //将x加到底部 modify(tot); //自底向上递归修复 } 接下来是删除堆顶操作，详解请看备注讲一下三目运算符 condition ? x : y condition为布尔型判断，为真返回x，为假返回y 123456789101112void repair(int x){ if(x*2 &gt; tot) return; //x已经是叶子节点 int target = x * 2; //target为两个子节点中较大的一个的序号 if(x*2+1 &lt;= tot) target = w[x*2] &gt; w[x*2+1] ? x*2 : x*2+1; //三目运算符，target等于较大一个子节点的序号 //这里是为了防止只有一个子节点的情况出现，所以提前赋值为2x再进行判断。 }void pop(){ swap(w[1],w[tot--]); //交换堆顶与堆尾然后删除堆尾 repair(1) //从根节点开始自上向下修复 } 自此我们实现了堆的所有操作，如果想要判断是否为空和堆的节点个数，通过tot的值便可以实现，这里不再给出具体的代码。 接下来我们引入一个模板题 堆的模板题https://www.luogu.com.cn/problem/P3378这是一道小根堆的模板题，大家可以前往自测，这里不做讲解只给出代码示范 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 100000007;int w[MAXN];int cnt = 0;int top(){ return w[1];}void modify(int x){ if(x == 1 || w[x] &gt; w[x / 2]) return; swap(w[x],w[x / 2]); modify(x / 2);}void push(int x){ w[++cnt] = x; modify(cnt);}void repair(int x){ if(x * 2 &gt; cnt) return; int tar = x * 2; if(x*2+1 &lt;= cnt) tar = w[x*2] &lt; w[x*2+1]? x*2:x*2+1; if(w[x] &gt; w[tar]) { swap(w[x],w[tar]); repair(tar); }}void pop(){ if(cnt) { swap(w[1],w[cnt--]); repair(1); } }int main(){ int n; cin&gt;&gt;n; while(n--) { int option; scanf(\"%d\",&amp;option); if(option == 1) { int x; scanf(\"%d\",&amp;x); push(x); } if(option == 2) printf(\"%d\\n\",top()); if(option == 3) pop(); } return 0;} 快速排序（堆排序）题目描述 将读入的 个数从小到大排序后输出。 输入格式 第一行为一个正整数 。 第二行包含 个空格隔开的正整数 ，为你需要进行排序的数。 输出格式 将给定的 个数从小到大输出，数之间空格隔开，行末换行且无空格。 样例输入 1254 2 4 5 1 样例输出 11 2 4 4 5 这是一个通过堆排序实现快排（用小根堆）的模板题，原理就是不断弹出堆顶，来从小到大输出数据。大家可以前往洛谷进行自测 点我跳转对比上一道题，这道题的做法就是将一组数据不断插入堆顶，然后输出一个，pop一个，进行n次操作。下面是伪代码示范 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;......int main(){ int n,x; cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) { cin&gt;&gt;x; push(x); } for(int i = 1; i &lt;= n; i++) { cout&lt;&lt;top()&lt;&lt;\" \"; pop(); } return 0;} 接着我们给出最后一道例题 [NOIP2004 提高组] 合并果子题目描述 在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。 每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。 因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。 例如有 种果子，数目依次为 ， ， 。可以先将 、 堆合并，新堆数目为 ，耗费体力为 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 ，耗费体力为 。所以多多总共耗费体力 。可以证明 为最小的体力耗费值。 输入格式 共两行。第一行是一个整数 ，表示果子的种类数。 第二行包含 个整数，用空格分隔，第 个整数 是第 种果子的数目。 输出格式 一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 。 样例输入 123 1 2 9 样例输出 115 通过题目描述我们不难看出，先合并的石子在后面会参与到后续的合并过程，这就导致它的重量会在后面反复被消耗，即先合并的果子后面其被搬运的次数越多，通过贪心策略我们不难得知，较小的体力消耗的次数越多我们最后体力消耗的总数越少，所以我们实现一个小根堆，每次连续取出两个小根堆堆顶的值，然后再将两个堆顶的和插入到堆中，直到堆为空。接下来给出伪代码 1234567while(tot &gt; 1) //tot为2时搬运最后一次，将最后两堆石子合在一起 { x = top(); pop(); y = top(); pop(); push(x + y); sum+=(x+y);} 优先队列（priority_queue）优先队列（priority_queue）是一种由STL操作的特殊的队列，它可以实现队列的功能，在此之上，实现队首是整个队列中的最大值（或最小值）它的底层逻辑是堆，需要包含&lt;queue&gt;头文件或者万能头，但是它只能访问队首（也就是最值）。接下里我们给出使用方法 12345priority_queue &lt;int&gt; q : 新建一个内部为int类型的优先队列q，默认q为大根堆priority_queue &lt;int,vector &lt;int&gt; ,greater &lt;int&gt; &gt; q : 新建一个小根堆 最后两个&gt; &gt;用空格隔开,否则与\"右移&gt;&gt;\"写法重复 q.top() : 查询优先队列最值（堆顶）q.pop() : 弹出堆顶q.push(k) : 将x插入优先队列 这样我们再回去做合并石子,并用STL操作优先队列来完成这道题目给出代码示范 12345678910111213141516171819202122232425#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n; cin&gt;&gt;n; int ans = 0; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; for(int i = 1; i &lt;= n; i++) { int k; cin&gt;&gt;k; q.push(k); } while(!q.empty()) { int temp = q.top(); q.pop(); temp+=q.top(); q.pop(); ans+=temp; if(!q.empty()) q.push(temp); } cout&lt;&lt;ans; return 0;}","categories":[],"tags":[{"name":"数据结构——入门","slug":"数据结构——入门","permalink":"https://fufffh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"}],"author":"Fufffh"},{"title":"栈（stack）","slug":"栈（stack）","date":"2024-10-26T11:19:00.000Z","updated":"2024-10-28T15:19:04.500Z","comments":true,"path":"2024/10/26/栈（stack）/","permalink":"https://fufffh.github.io/2024/10/26/%E6%A0%88%EF%BC%88stack%EF%BC%89/","excerpt":"","text":"什么是栈？我们先回顾一下我们对于队列的学习。我们对于队列的理解，是一个队伍，在队尾进入，先进先出。那么我们应该通过什么来理解栈呢？你可以想象一堆叠在一起的书构成“书塔”，由下往上叠放。每次放书都放在最上面那层书的上面，如果你想取书，由于书的重力你很难从“书塔”的中间取出来书，所以你只能从这一叠书的最上面取书。所以我们每次取书都是取得最上面得一本。你可以理解为一个单头的队列，只有队首，插入元素和删除元素都是针对队首进行的。这种性质使得栈中先插入的元素会在后插入元素的“下方”,但是出栈是从所谓“上面”出栈，所以这就使得先插入的元素的出栈顺序在后插入的元素之后，所以栈具有先进后出的性质。 栈的代码实现123const int MAXN = 10000007;int stack[MAXN];int p = 0; //栈顶指针 不难理解，依然类似于队列，我们通过数组和指针实现栈。这里的MAXN指的是栈最大支持的大小;接下来是操作代码的实现 12345678910void push(int a){ if(p &gt;= MAXN) cout&lt;&lt;\"Stack overflow（栈溢出）\"; else stack[p++] = x;}void pop(){ if(p == 0) cout&lt;&lt;\"Stack is empty（栈为空）\"; else p--;} 你可以理解下一个插入的元素为stack[p],如果弹出过一次，我们通过更改stack[p-1]来实现所以弹出栈顶用p--来减少指针的值，使得下一次插入的元素通过赋值顶替已经删除的栈顶来实现栈顶的删除。比如3 5 1 7 指针为4,弹出一次操作进行后指针变为3，弹出的元素是stack[3]，下一次插入元素插入到stack[3],通过后续新的元素的插入来实现之前已经删除的栈顶指针索引下的数值的变化（删除）。所以这就是为什么MAXN在队列中表示最大插入次数，因为他的元素没有经过实际意义上数组中的删除，只是滚动过去实现队列的模拟。但在栈中是实际上通过删除来实现的，所以在栈中MAXN指的是栈的大小。 接着给出访问栈顶的代码 123456789int top(){ if(p == 0) { cout&lt;&lt;\"Stack is empty（栈为空）\"; return -1; //指的是栈为空这个概念 } else return stack[p - 1];} 这样我们就实现了栈的基本操作。和队列一样，栈也有对应的STL中的栈,接下来给出通过STL操作的栈的用法。 1234567&lt;stack&gt; : 栈所需要的头文件 stack&lt;int&gt; s : 建立一个栈s,其内部元素类型为ints.push(k) : 将元素k压入栈ss.pop() : 弹出栈顶元素s.top() : 访问栈定元素s.size() : 查询栈s的元素个数s.empty() : 查询s是否为空 写在最后栈的实现相对于队列比较简单，这里不给出具体的例题了，大家可以自行拟定一些数据进行模拟。在栈的基础之上，我们还有一种数据结构——单调栈，它将在后续的进阶数据结构中讲到,敬请期待","categories":[],"tags":[{"name":"数据结构——入门","slug":"数据结构——入门","permalink":"https://fufffh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"}],"author":"Fufffh"},{"title":"队列（queue）","slug":"队列（queue）","date":"2024-10-26T06:59:45.000Z","updated":"2024-10-28T15:19:14.867Z","comments":true,"path":"2024/10/26/队列（queue）/","permalink":"https://fufffh.github.io/2024/10/26/%E9%98%9F%E5%88%97%EF%BC%88queue%EF%BC%89/","excerpt":"","text":"什么是队列？队列（queue）是一种数据结构,它的特点是只允许从队尾入队，从队列头部出队，满足先进先出的性质，即先进入队列的元素先出队列。可以把它理解为排队排在前一个人的后面。比如数字1 5 7 9 2的队列，插入一个元素3，应该插入到队尾，成为3 1 5 7 9 2，再插入一个5，应该排到3的前面，变成5 3 1 5 7 9 2，出队一个头部元素2，则成为3 1 5 7 9，所以满足先进队列的先出队的先进先出性质。此外，队列只允许队首出队，新元素也只能在队尾入队,访问只能访问队首和队尾,无法从中间进行入队出队的操作也无法访问队列中间的元素。 队列（queue）的代码实现123int queue[MAXN];int head = 0;int tail = 0; 数组为队列开辟需要的存储仪器,是队列的最大能入队元素的次数,一般开一个较大的数防止溢出、为指示队首与队尾元素的两个指针。如果有新元素插入，就会插入到这个位置 12345void push(int x){ if(tail &gt;= MAXN) cout&lt;&lt;\"Queue overflow (队列溢出)\"; else queue[tail++] = x; //插入新的元素 } 这是插入操作，我们接着给出出队操作，两个结合着来讲解。 12345void pop() //弹出队首需要判断队列是否为空 { if(head == tail) cout&lt;&lt;\"Queue is empty（队列为空）\"; else head++;} 解释：队列元素插入数组后就一直在数组中，我们通过的是首尾指针的增减来实现队列的还原。比如插入3 5 1，那么queue[0~2]分别指代3 5 1。此时 下次插入会从queue[3]插入元素，queue[head]指代的是队首的3。 函数中会增加队首指针的值，比如进行一次出队操作,增加为1，指代queue[1]，也就是5,但是删除的元素3并不会删除数组，只是两个指针向后滚动来还原整个队列。进行第二次出队,head = 2，指代元素1。如果再进行一次出队，此时已经进行三次出队,head = tail = 3,那么队列为空。这样我们便实现了出队和入队的操作，下面给出访问队首的操作。 123456789int front(){ if(head == tail) { cout&lt;&lt;\"Queue is empty（队列为空）\"; return -1; // 队列为空返回-1，此处也可以返回别的数，因为这并不代表一个对内元素，只代表“空队列”这个概念 } else return queue[head]; //队列不为空，返回队首 } 接下来我们给出一道Luogu例题：https://www.luogu.com.cn/problem/P1996 大家可以在上面自测代码。 约瑟夫问题题目描述 个人围成一圈，从第一个人开始报数,数到 的人出列，再由下一个人重新从 开始报数，数到 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。 输入格式 输入两个整数 。 输出格式 输出一行 个整数，按顺序输出每个出圈人的编号。 样例输入 110 3 样例输出 13 6 9 2 7 1 8 5 10 4 对于这道问题，我们发现会形成一个所谓的约瑟夫环，报数时候如果报的数字不是,那么就可以让把队首放到队尾，通过访问队首元素并将其复制到队尾然后再队首出队实现。报完次后，开始队首出队，出队前输出队首，然后接着循环即可。代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std;const int MAXN = 10000007;int queue[MAXN];int head = 0;int tail = 0; int n,m;void push(int x){ if(tail &gt;= MAXN) cout&lt;&lt;\"Queue overflow (队列溢出)\"; else queue[tail++] = x;}void pop(){ if(head == tail) cout&lt;&lt;\"Queue is empty（队列为空）\"; else head++;}int front(){ if(head == tail) { cout&lt;&lt;\"Queue is empty（队列为空）\"; return -1; } else return queue[head]; }int main(){ cin&gt;&gt;n&gt;&gt;m; for(int i = 1; i &lt;= n; i++) push(i); while(head != tail) //如果队列不为空就一直进行循环 { for(int i = 1; i &lt; m; i++) { push(front()); pop(); //上面两步实现了将队首元素换到队尾 } cout&lt;&lt;front()&lt;&lt;\" \"; pop(); //报数到m，队首出队 } return 0;} 我们补充一个访问队尾元素的代码 12345678int back() { if (head == tail) { cout &lt;&lt; \"Queue is empty (队列为空)\"; return -1; } return queue[tail - 1]; // 返回队尾元素} 需要注意的一点，如果这里我们使用的头文件库有queue*或者是包含了该头文件的万能头bits/stdc++.h,数组的命名就不能使用queue。可以使用q或者其他名字来命名数组。那是为什么呢？这里我们引出一个头文件queue中自带的现成的队列，使用STL来进行操作。 STL中的队列（queue）12345678#include&lt;queue&gt; : 队列所需要的头文件queue&lt;int&gt; q : 建立一个队列q，其内部元素类型为intq.push(k) : 将元素k插入队列q中q.pop() : 队列q队首出队q.front() : 访问队列q的队首元素q.back() : 访问队列q的队尾元素q.size() : 查询队列q的元素个数q.empty() : 查询队列是否为空 特别注意： q.empty()为空返回真接着我们使用STL中的队列来重新做一下这道题目 12345678910111213141516171819#include&lt;bits/stdc++.h&gt;using namespace std;int main(){ int n,m; cin&gt;&gt;n&gt;&gt;m; queue&lt;int&gt;q; for(int i = 1; i &lt;= n; i++) q.push(i); while(q.size()) //判断队列是否为空，在这里等价为while(!q.empty()) { for(int i = 1; i &lt; m; i++) { q.push(q.front()); q.pop(); } cout&lt;&lt;q.front()&lt;&lt;\" \"; q.pop(); } return 0;} 双端队列（deque）文章的最后我们再给出一个STL中自带的双端队列（deque）,支持队首队尾都能删除和插入元素,用法如下 123456789deque&lt;int&gt; q : 建立双端队列qq.push_back(k) : 在队尾插入元素kq.push_front(k) : 在队首插入元素kq.pop_back() : 移除队尾元素 q.pop_front() : 移除队首元素q.front() : 访问队首元素q.back() : 访问队尾元素q.size() : 查询队列的元素个数 q.empty() : 查询队列是否为空 写在最后自此，我们讲完了队列的实现和使用。队列不仅作用于一些特殊情境的模拟，在一些算法（宽度优先搜索，迪杰斯特拉算法等等）中都有使用。同时它是我们讲解的第一个数据结构，对于后续数据结构的实现和使用了提供了一些思想上的经验。除了上面提到的最常见的队列，以及不常见的双端队列，我们还有一个经常使用的队列，叫做优先队列（priority_queue），不过这是一种基于堆（heap）实现的数据结构，将在后续的文章中进行讲解，如有需要，请点击此处前往学习","categories":[],"tags":[{"name":"数据结构——入门","slug":"数据结构——入门","permalink":"https://fufffh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"}],"author":"Fufffh"},{"title":"线性dp","slug":"线性dp","date":"2024-10-25T15:41:13.000Z","updated":"2024-10-28T15:19:05.726Z","comments":true,"path":"2024/10/25/线性dp/","permalink":"https://fufffh.github.io/2024/10/25/%E7%BA%BF%E6%80%A7dp/","excerpt":"","text":"对于线性动态规划，顾名思义指的就是根据题目内容可以得出线性相关的动态规划，如果书有序列（数组）那么状态就是一维的，如果是网格（棋盘）那么就是二维的。前文引例中的题目便是这种类型的。线性动态规划定义状态通常会考虑某类有序事件前面若干子事件的和 接下来我们给出例题 [HNOI2004] 打鼹鼠题目描述 鼹鼠是一种很喜欢挖洞的动物，但每过一定的时间，它还是喜欢把头探出到地面上来透透气的。根据这个特点阿牛编写了一个打鼹鼠的游戏：在一个 的网格中，在某些时刻鼹鼠会在某一个网格探出头来透透气。你可以控制一个机器人来打鼹鼠，如果 时刻鼹鼠在某个网格中出现，而机器人也处于同一网格的话，那么这个鼹鼠就会被机器人打死。而机器人每一时刻只能够移动一格或停留在原地不动。机器人的移动是指从当前所处的网格移向相邻的网格，即从坐标为 的网格移向 四个网格，机器人不能走出整个 的网格。游戏开始时，你可以自由选定机器人的初始位置。 现在知道在一段时间内，鼹鼠出现的时间和地点，请编写一个程序使机器人在这一段时间内打死尽可能多的鼹鼠。 输入格式 第一行为 （，），其中 表示在这一段时间内出现的鼹鼠的个数，接下来的 行中每行有三个数据 表示在游戏开始后 个时刻，在第 行第 个网格里出现了一只鼹鼠。 按递增的顺序给出。注意同一时刻可能出现多只鼹鼠，但同一时刻同一地点只可能出现一只鼹鼠。 输出格式 仅包含一个正整数，表示被打死鼹鼠的最大数目。 样例输入 1232 2 1 1 1 2 2 2 样例输出 11 我们首先引入一个定义————曼哈顿距离,又叫直角距离，指的是两点间横纵坐标差的绝对值的和，例如、，那么、的曼哈顿距离为 后面我们也会用到曼哈顿距离 未完待续","categories":[],"tags":[{"name":"算法——DP","slug":"算法——DP","permalink":"https://fufffh.github.io/tags/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94DP/"}],"author":"Fufffh"},{"title":"动态规划（DP）的引入","slug":"动态规划（DP）的引入","date":"2024-10-24T11:43:56.000Z","updated":"2024-10-28T15:19:18.930Z","comments":true,"path":"2024/10/24/动态规划（DP）的引入/","permalink":"https://fufffh.github.io/2024/10/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88DP%EF%BC%89%E7%9A%84%E5%BC%95%E5%85%A5/","excerpt":"","text":"动态规划的介绍动态规划(Dynamic Programming)，简称DP，是运筹学的一个分支，用于解决多阶段决策过程中的最优化的一种数学方法，把多阶段问题变换为系列单阶段的问题加以解决的方法。 所以动态规划其实是一种数学方法，是求解某类问题的一种方法，不是一种特定的算法，更没有标准的数学表达式或者明确的定义的一种规则。 动态规划的根本是一种解决问题的思路，思考问题的方式，而不是具体的方法。所以动态规划的难点是思想上的，在于如何学会这种思想。这导致如果我们学习不善，很多时候会构造不出来动态规划所需要的形式，甚至根本想不到这是一道动态规划的问题。 而动态规划的基本思想，就是将一个大问题分解成若干个简单的小问题来求解。其中每一个阶段都需要做出决策，从而使得整个过程达到最优。 动态规划的三个重要要素 状态动态规划的状态可以相对笼统的理解为“问题所在的局面”，例如，“从第i个数字到第j个数字的最大下降子系列”就是状态，是一种关于i,j的局面，然后“最”大下降子序列就是问题所对应的最优答案。某状态表示的答案（的值），方案（集合），在本质上相同，通常会用一个字母（或）表示。状态的答案只依赖状态定义的局面和一些状态以外的常量。在一般情况下，状态变化不会影响状态以外的量，同时状态之后的演变也不受这个状态之前决策的影响。所以在使用动态规划时，应该将所有的可能的变动加入状态的定义中去。同时我们也要定义一个初始状态，即初始化，也称为边界条件 状态转移与状态转移方程因为要求解最终状态的答案，所以状态之间需要存在某些关系，一般把这种计算关系称作转移，关系式称为状态转移方程。寻找状态转移方程也是求解动态规划问题答案的关键所在。状态转移方程一般具有它自己的意义，体现的是从一个状态到另一个状态的变化。对于最优化问题来说，转移方程的目的就是找到最优的前继情况的答案并取出最优答案。前继状态的最优解与当前状态之间最优解的关联性被成为动态规划的最优子结构性质。对于计数问题来说，转移方程的目的就是不遗漏、不重复地统计所有可能的方案数。状态转移存在两种方式，被称为发送型和接收型，前者枚举状态的后继，并计算对后继的贡献;后者枚举状态的前继，当即计算出状态的答案。选取主要取决于前后继状态枚举的难度和转移的复杂程度。 无后效性各阶段的决策的一个前提是“仅需要依赖当前状态”，指的是问题的历史状态不影响未来的发展，可以理解为一个局面可以从哪些局面转移过来的单向依赖关系，如果两个局面可以“相互依赖”，即相互转移到达，那么这个问题，或者说你所定义的当前的这个状态，不具备用动态规划解决的性质。比如从一道题：一个人从左上角到右下角，其间有各种障碍，问最短路径。当你走到某一个点位的时候，你定义的状态应该是向右或者向下，而不是向左或者向上，因为如果这样，那么该点局面就会转移到上方或者左方，是反向的，形成了所谓的“双向依赖”，这种互相达到是动态规划不可以拥有的。我们将这种状态之间不能互相达到的性质以及未来与过去无关的性质统称为动态规划的无后效性。 接下来我们通过例题进行演示最长字段和题目描述给出一个长度为n的序列a,选中期中连续且非空的一段使得这段和最大。 输入格式：第一行是一个整数n,表示序列的长度；第二行有n个整数，第i个整数表示。 输出格式：输出一个整数表示答案。 样例 输入72 -4 3 -1 2 -4 3 输出4 我们定义一个 表示从从1到i之间的最大子段和 首先需要初始化 对于，有两种方式转移过来一种是时，我们可以选择枚举到第i个数的最大子段和为第i个数的值加上一种是时，我们选择枚举到第i个数的自打字段和为 对于这个转移，我们可以进一步思考，如果，那么同理,如果，那么。 则我们可以写出状态转移方程 还需要一个 维护一个ans为最大值 接下来给出代码 123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 10000007;int n,f[MAXN],a[MAXN],ans = -1*MAXN;int main(){ cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; for(int i = 1; i &lt;= n; i++) { f[i] = max(f[i - 1] + a[i],a[i]); ans = max(ans,f[i]); //维护一个ans为最大值 } cout&lt;&lt;ans; return 0;} 当然对于此题的状态转移方程，我们也可以写为 这与上式是等价的接下来我们来看下一道例题 长廊灯泡问题题目描述长廊的墙上等距离排列着一列灯泡，每个灯泡发出的亮度不一样，因为灯泡的质量不达标，所以不能出现两个相邻灯泡都打开的情况，否则会因为温度过高导致灯泡毁坏。问灯泡应该怎样开，才可以使长廊的总亮度最大？输出这个最大值。 输入格式：第一行是一个整数n,表示灯泡的数量；第二行有n个整数，第i个整数表示灯泡的亮度。 输出格式：输出一个整数表示答案。 样例 输入52 7 9 3 1 输出12 对于这道题目，可以理解为求不相邻数字和的最大值。 首先定义一个,表示1到i个数字的不相邻数字和的最大值 初始化 表示第1个灯泡和第2个灯泡只能开一个 接着分析的转移对于第i个灯泡，有两种情况 如果第i-1个灯泡未开，那么第i个灯泡可以开，即 如果第i-1个灯泡打开了，那么第i个灯泡则不能打开，则 我们可以得到状态转移方程 即为最终答案代码示例如下 12345678910111213#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 10000007;int n,f[MAXN],a[MAXN];int main(){ cin&gt;&gt;n; for(int i = 1; i &lt;= n; i++) cin&gt;&gt;a[i]; f[1] = a[1]; f[2] = max(a[1],a[2]); for(int i = 1; i &lt;= n; i++) f[i] = max(f[i - 2] + a[i],f[i - 1]); cout&lt;&lt;f[n]; return 0;} 接着我们给出最后一道例题 [NOIP2002 普及组] 过河卒题目描述棋盘上 点有一个过河卒，需要走到目标 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。 棋盘用坐标表示， 点 、 点 ，同样马的位置坐标是需要给出的。 现在要求你计算出卒从 点能够到达 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。 输入格式一行四个正整数，分别表示 点坐标和马的坐标。 输出格式一个整数，表示所有的路径条数。 样例 输入6 6 3 3 输出6 我们首先分析这道题目，一个点可以由它的上一个点和左边一个点得到，同时也可以由它的右边和下面的点得到。但是dp的一个根本思想是不能形成相互依赖的结构，如果这样，那么便会形成。因为题目是从左上角到右下角，所以一个点的答案只由它左边和上面的点转移而来。是二点方案数的总和。所以我们的转移方程不难推出 后面给出代码解析 123456789#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,x,y;long long f[50][50]; // 到坐标(i,j)时的方案总数 //十年oi一场空，不开long long见祖宗 bool is[50][50]; // 判断是否可以经过 //数组开大一点 不然跳马可能会越界导致结果出现错误 int move_x[8] = {1,1,2,2,-1,-1,-2,-2};int move_y[8] = {2,-2,1,-1,2,-2,1,-1}; //马的八种移动方式对应的坐标的变化 解释一下 这里需要开long long是因为会出现爆int的情况，这道题也确实卡了int，这在算法题目中需要注意is数组开大，是因为跳马的落脚点可能超出数组的范围，导致数组越界产生报错。 12345678910111213141516cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y; memset(is,true,sizeof(is)); //默认全部点位可经过 memset(f,0,sizeof(f)); //答案默认为0 is[x][y] = false; //马所在的点为控制点之一，不可经过 for(int i = 0; i &lt; 8; i++) is[x + move_x[i]][y + move_y[i]] = false; //八个跳马点标记为不可经过 for(int i = 0; i &lt;= n; i++) { if(!is[i][0]) break; f[i][0] = 1; } for(int j = 0 ; j &lt;= m; j++) { if(!is[0][j]) break; f[0][j] = 1; } //第0行的都是1，如果有一个点是控制点，那么该点之后的点以及该点都为0 首先前四行代码不难理解后面代码的解释：第0行，第0列的所有数的值都应该是1，但是如果期中有一个点是落脚点，那么它无法向后（向下）转移，那么该点之后（包括该点）的所有答案数都应该为0.后面几行代码实现了这样一种落脚点在第0行（列）的特殊情况 接下来给出状态转移的代码 123for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) if(is[i][j]) f[i][j] = f[i - 1][j] + f[i][j - 1]; //状态转移方程 全部代码如下 1234567891011121314151617181920212223242526272829#include&lt;bits/stdc++.h&gt;using namespace std;int n,m,x,y;long long f[50][50];bool is[50][50];int move_x[8] = {1,1,2,2,-1,-1,-2,-2};int move_y[8] = {2,-2,1,-1,2,-2,1,-1}; int main(){ cin&gt;&gt;n&gt;&gt;m&gt;&gt;x&gt;&gt;y; memset(is,true,sizeof(is)); memset(f,0,sizeof(f)); is[x][y] = false; for(int i = 0; i &lt; 8; i++) is[x + move_x[i]][y + move_y[i]] = false; for(int i = 0; i &lt;= n; i++) { if(!is[i][0]) break; f[i][0] = 1; } for(int j = 0 ; j &lt;= m; j++) { if(!is[0][j]) break; f[0][j] = 1; } for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) if(is[i][j]) f[i][j] = f[i - 1][j] + f[i][j - 1]; cout&lt;&lt;f[n][m]; return 0;}","categories":[],"tags":[{"name":"算法——DP","slug":"算法——DP","permalink":"https://fufffh.github.io/tags/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94DP/"}],"author":"Fufffh"},{"title":"宽度优先搜索（BFS）","slug":"宽度优先搜索（BFS）","date":"2024-10-20T04:19:04.000Z","updated":"2024-10-28T15:19:12.520Z","comments":true,"path":"2024/10/20/宽度优先搜索（BFS）/","permalink":"https://fufffh.github.io/2024/10/20/%E5%AE%BD%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89/","excerpt":"","text":"前置知识注意 该算法的前置知识为队列（queue）,如果没有学习，请点击这里进行学习 BFS的介绍BFS（宽度优先搜索 Breadth-First Search）是一种用于图的遍历或搜索的算法。它从一个节点开始，逐层遍历图中的所有节点。BFS通常用队列来实现，因为它需要按照节点的发现顺序来访问它们。 工作原理BFS的工作原理可以总结为以下几个步骤 循环：只要队列不为空，就执行以下操作： 出队一个节点（我们称之为当前节点）。 访问当前节点的所有未访问的邻居节点（子节点）。 将每个未访问的邻居节点（子节点）标记为已访问，并将其入队。 BFS算法的特点 层级遍历：它按层级顺序访问节点，这意味着它会先访问所有与源节点相邻的节点，然后是那些节点的邻居，以此类推。 最短路径：在无权图中，BFS可以找到从源节点到其他任何节点的最短路径。 时间复杂度：对于有V个顶点和E条边的图，BFS的时间复杂度是O(V+E)。 空间复杂度：在最坏的情况下，BFS可能需要O(V)的空间来存储所有节点的访问状态。 图示演示下面进行进行图示演示： 首先1为根节点 假如我们使用的是DFS，那么DFS序如下 如果我们使用BFS，那么可以理解为按照深度对图进行分层，例如下图，分为1-4共4层，每次遍历先遍历完上一层的所有节点，接着再遍历下一层，首先根节点1入队,遍历完1之后，1的所有子节点入队，1做一次标记并且退队 然后接着对队列中的元素2、3、4、5进行遍历，遍历完2后将2的子节点入队并且对2做标记且让2出队，后续接着遍历完3、4、5，各自子节点入队后各自再做一次标记并退队 接着遍历队列中的元素，直到最后一个元素退队后没有新的元素入队，即队列为空，遍历结束 例题：马的遍历依然是DFS中出现的这道Luogu例题： https://www.luogu.com.cn/problem/P1443 我们接下来用BFS的方法解答一下 123456789101112131415161718#include&lt;bits/stdc++.h&gt;using namespace std;int num[401][401]; //存一下答案，num[i][j]为马到点(i,j)所需要的最小步骤数 struct node&#123; int x,y;&#125;; //定义一个结构体,存储一个点的x,y坐标 queue&lt;node&gt;q; //使用stl自带的队列 也可以自己手写一个 int move_x[8] = &#123;1,1,2,2,-1,-1,-2,-2&#125;;int move_y[8] = &#123;2,-2,1,-1,2,-2,1,-1&#125;; //马的八种移动方式对应的坐标变化 int main()&#123; int n,m,begin_x,begin_y; cin&gt;&gt;n&gt;&gt;m&gt;&gt;begin_x&gt;&gt;begin_y; memset(num,-1,sizeof(num)); //初始化所有答案为-1 num[begin_x][begin_y] = 0; //马到初始点的距离为1 node tmp = &#123;begin_x,begin_y&#125;; //将起点入队 q.push(tmp); ......&#125; 接下来开始BFS，代码如下 12345678910111213141516while(!q.empty()) //队列不为空，就继续进行 &#123; node now = q.front(); //遍历对首并取值 q.pop(); //弹出队首 int now_x = now.x;int now_y = now.y; //储存队首的坐标 for(int i = 0; i &lt; 8; i++) &#123; int next_x = now_x + move_x[i]; int next_y = now_y + move_y[i]; //八个坐标值变化情况 if(next_x &lt; 1 || next_y &lt; 1 || next_x &gt; n || next_y &gt; m || num[next_x][next_y] != -1) continue; //如果x,y坐标不符合图示，或者num[next_x][next_y] != -1,即next点已经被遍历过，舍弃该种情况 num[next_x][next_y] = num[now_x][now_y] + 1; //更新答案，下一个点位为上一个点位的距离加1 node t = &#123;next_x,next_y&#125;; //访问next节点 q.push(t); //将next节点插入队尾 &#125;&#125; 然后我们就完成了对所有情况的遍历，接着对答案进行输出 12345for(int i = 1; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= m; j++) cout&lt;&lt;num[i][j]&lt;&lt;&quot; &quot;; //场宽 cout&lt;&lt;endl; //换行 &#125; 然后我们就完成了这道题目。全部代码如下 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;int num[401][401];struct node&#123; int x,y;&#125;;queue&lt;node&gt;q;int move_x[8] = &#123;1,1,2,2,-1,-1,-2,-2&#125;;int move_y[8] = &#123;2,-2,1,-1,2,-2,1,-1&#125;;int main()&#123; int n,m,begin_x,begin_y; cin&gt;&gt;n&gt;&gt;m&gt;&gt;begin_x&gt;&gt;begin_y; memset(num,-1,sizeof(num)); num[begin_x][begin_y] = 0; node tmp = &#123;begin_x,begin_y&#125;; q.push(tmp); while(!q.empty()) &#123; node now = q.front(); q.pop(); int now_x = now.x;int now_y = now.y; for(int i = 0; i &lt; 8; i++) &#123; int next_x = now_x + move_x[i]; int next_y = now_y + move_y[i]; if(next_x &lt; 1 || next_y &lt; 1 || next_x &gt; n || next_y &gt; m || num[next_x][next_y] != -1) continue; num[next_x][next_y] = num[now_x][now_y] + 1; node t = &#123;next_x,next_y&#125;; q.push(t); &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) cout&lt;&lt;num[i][j]&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125; return 0;&#125;","categories":[],"tags":[{"name":"算法——基础","slug":"算法——基础","permalink":"https://fufffh.github.io/tags/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80/"}],"author":"Fufffh"},{"title":"深度优先搜索（DFS）","slug":"深度优先搜索（DFS）","date":"2024-10-19T15:47:34.000Z","updated":"2024-10-28T15:19:09.441Z","comments":true,"path":"2024/10/19/深度优先搜索（DFS）/","permalink":"https://fufffh.github.io/2024/10/19/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89/","excerpt":"","text":"DFS的介绍DFS（深度优先搜索，Depth-First Search）是一种用于遍历或搜索树或图的算法。它从一个节点开始，尽可能深地搜索树的分支，直到到达叶子节点（没有子节点的节点），然后回溯到上一个节点，继续搜索其他分支。这个过程会一直进行，直到所有可能的分支都被探索完毕。 工作原理DFS的工作原理可以总结为以下几个步骤 选择一个起始节点：从树或图的某个节点开始。 探索尽可能深的分支：从当前节点开始，选择一个未被访问过的邻接节点，然后递归地在该节点上执行DFS。 回溯：当当前节点的所有邻接节点都被访问过，或者到达了叶子节点时，回溯到上一个节点。 重复：重复步骤2和3，直到所有节点都被访问过。 DFS的特点 栈的使用：在实现DFS时，通常使用栈数据结构来存储节点。在递归实现中，调用栈隐式地充当了栈的角色。 时间复杂度：对于有V个顶点和E条边的图，DFS的时间复杂度通常是O(V + E)。 空间复杂度：在最坏的情况下，DFS的空间复杂度也是O(V)，因为可能需要存储整个路径上的节点。 路径搜索：DFS非常适合于寻找从起点到终点的路径，尤其是在图不是非常大的情况下。 连通性问题：DFS可以用来检测图的连通性，例如，检查一个图是否是强连通的。 图示示例下面是一个简单的图示：节点1为根节点，也叫起始节点那么节点1向下遍历，直到遍历到第一个没有子节点的节点4因为4已经没有子节点，已经是叶子节点，所以无法再向下遍历，所以回溯到上一个它的父节点3，并对节点4作标记，节点3接着向下遍历未被标记的子节点5因为5同样是叶子节点，遍历有到达了最深层，所以继续回溯到父节点3，同时标记5，我们发现3也没有未被标记的子节点了，无法再向下遍历，那么3接着向上回溯到父节点2，同时对3作标记，继续遍历2的未被标记的子节点6接下来过程：2→6→7，节点7向上回溯到6并标记,节点6向下遍历子节点:6→8,然后连续向上回溯 8→6→2→1 直到回溯到根节点1,发现有可以向下遍历的子节点接着按照上述模式进行剩余的遍历，完成整张图的遍历，图的序号即为遍历的顺序 例题：马的遍历这是Luogu上一道搜索的例题 https://www.luogu.com.cn/problem/P1443接着给出示例代码 123456789#include&lt;bits/stdc++.h&gt; //万能头文件 using namespace std; //引用stl库 const int MAXN = 1000009; //定义一个大数 bool is[401][401]; //对一个点(i,j)标记是否已经遍历过 int num[401][401]; //存储起始点(x,y)到每个点(i,j)的距离 int n,m,begin_x,begin_y;int move_x[8] = &#123;1,1,2,2,-1,-1,-2,-2&#125;;int move_y[8] = &#123;2,-2,1,-1,2,-2,1,-1&#125;; //马的八种移动方式对应的(x,y)坐标的变化 初始工作 123456789int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;begin_x&gt;&gt;begin_y; memset(is,true,sizeof(is)); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) num[i][j] = MAXN; dfs(begin_x,begin_y,0); print(); return 0;&#125; main函数的内容如上，初始化标记数组is,为全部未访问过，num[i][j]初始化为一个极大的数dfs(int x,int y,int k)为一个递归函数 x,y:当前点位的横坐标; k:走到目前点位的步数dfs(begin_x,begin_y,0) 即从初始点位开始dfs，步数为0（马到起始点的步数为0） 123456789101112131415161718void dfs(int x,int y,int k)&#123; if(x &lt;= 0||y &lt;= 0||num[x][y] &lt; k||x &gt; n || y &gt; m) return; //如果遍历到的坐标点不在方格图内 即超过了图的横纵坐标或者小于等于0（方格图横纵坐标范围为1~n,1~m） 回溯 //num[x][y] &lt; k ： 如果该点位的答案已经小于现有步数，那么k已经超过了答案，没有必要进行 回溯 num[x][y] = k; //更新num[x][y] for(int i = 0 ;i &lt; 8; i++) //枚举八个走马后的可能坐标值 &#123; int tx = move_x[i] + x; int ty = move_y[i] + y; //(tx,ty) : 走马后的坐标 is[x][y] = false; dfs(tx,ty,k + 1); //向后遍历，步数加1，打标记，防止父子节点反复遍历死循环 is[x][y] = true; //恢复标记，可以再次访问 &#125;&#125; dfs内容如上 接着我们需要对题目所要求的输出进行修改，有格式要求 123456789101112void print()&#123; for(int i = 1 ; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; if(num[i][j] == MAXN) cout&lt;&lt;&quot;-1 &quot;; else cout&lt;&lt;num[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;&#125; 当然你也可以采取下面修改场宽的方式进行所要求格式的输出 1printf(&quot;%-5d&quot;,num[i][j]); 全部代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;const int MAXN = 1000009;bool is[401][401];int num[401][401];int n,m,begin_x,begin_y;int move_x[8] = &#123;1,1,2,2,-1,-1,-2,-2&#125;;int move_y[8] = &#123;2,-2,1,-1,2,-2,1,-1&#125;; void dfs(int x,int y,int k)&#123; if(x &lt;= 0||y &lt;= 0||num[x][y] &lt; k||x &gt; n || y &gt; m) return; num[x][y] = k; for(int i = 0 ;i &lt; 8; i++) &#123; int tx = move_x[i] + x; int ty = move_y[i] + y; is[x][y] = false; dfs(tx,ty,k + 1); is[x][y] = true; &#125;&#125;void print()&#123; for(int i = 1 ; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= m; j++) &#123; if(num[i][j] == MAXN) cout&lt;&lt;&quot;-1 &quot;; else cout&lt;&lt;num[i][j]&lt;&lt;&quot; &quot;; &#125; cout&lt;&lt;endl; &#125;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;begin_x&gt;&gt;begin_y; memset(is,true,sizeof(is)); for(int i = 1; i &lt;= n; i++) for(int j = 1; j &lt;= m; j++) num[i][j] = MAXN; dfs(begin_x,begin_y,0); print(); return 0;&#125; 在代码中，DFS被用来计算从起点开始，到达每个位置所需的最少移动次数。虽然最终结果可能是正确的，但由于DFS的递归性质，它可能会导致大量的函数调用开销，并且可能会在没有找到更优解的情况下继续深入搜索，从而导致效率较低。 接下来 将引入在这个场景下更为合适的另一种搜索方法，宽（广）度优先搜索（BFS）","categories":[],"tags":[{"name":"算法——基础","slug":"算法——基础","permalink":"https://fufffh.github.io/tags/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80/"}],"author":"Fufffh"}],"categories":[],"tags":[{"name":"数论","slug":"数论","permalink":"https://fufffh.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"本科教学知识","slug":"本科教学知识","permalink":"https://fufffh.github.io/tags/%E6%9C%AC%E7%A7%91%E6%95%99%E5%AD%A6%E7%9F%A5%E8%AF%86/"},{"name":"基础知识","slug":"基础知识","permalink":"https://fufffh.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"数据结构——进阶","slug":"数据结构——进阶","permalink":"https://fufffh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E8%BF%9B%E9%98%B6/"},{"name":"数据结构——入门","slug":"数据结构——入门","permalink":"https://fufffh.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"},{"name":"算法——DP","slug":"算法——DP","permalink":"https://fufffh.github.io/tags/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94DP/"},{"name":"算法——基础","slug":"算法——基础","permalink":"https://fufffh.github.io/tags/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%9F%BA%E7%A1%80/"}]}